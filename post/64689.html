<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"framist.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="【软件与系统安全】">
<meta property="og:type" content="article">
<meta property="og:title" content="【软件与系统安全】笔记与期末复习">
<meta property="og:url" content="https://framist.github.io/post/64689.html">
<meta property="og:site_name" content="Framist&#39;s Little House">
<meta property="og:description" content="【软件与系统安全】">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-a8e3e7faf24593996366c66a77ba0a49.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-17ba13d53e49ec05521c1d8dd16013c1.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-722917acd9a52369595d6b90dc043037.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-523ab6128d6c53d422a732896477d2f2.png">
<meta property="article:published_time" content="2022-09-16T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-22T07:43:54.296Z">
<meta property="article:author" content="Framist">
<meta property="article:tag" content="二进制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-a8e3e7faf24593996366c66a77ba0a49.png">

<link rel="canonical" href="https://framist.github.io/post/64689.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【软件与系统安全】笔记与期末复习 | Framist's Little House</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <meta name="google-site-verification" content="L6yHwE6A2iaXD8k96v05szGztESL_4f9nVI5lxU25h0" />
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Framist's Little House</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">◇ 自顶而下 - 面向未来 ◇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-safc">

    <a href="/safc/" rel="section"><i class="fa fa-landmark fa-fw"></i>SAFC</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://framist.github.io/post/64689.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Framist">
      <meta itemprop="description" content="框架主义者的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Framist's Little House">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【软件与系统安全】笔记与期末复习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2022-09-17T00:00:00+08:00">2022-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-22 15:43:54" itemprop="dateModified" datetime="2023-09-22T15:43:54+08:00">2023-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%AF%BE%E4%B8%9A%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">课业学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="【软件与系统安全】"><a href="#【软件与系统安全】" class="headerlink" title="【软件与系统安全】"></a>【软件与系统安全】</h1><p><img data-src="https://pic4.zhimg.com/80/v2-a8e3e7faf24593996366c66a77ba0a49.png" alt="Image"></p>
<span id="more"></span>

<h2 id="关于课程"><a href="#关于课程" class="headerlink" title="关于课程"></a>关于课程</h2><p>西电网信院 网安实验班 软件与系统安全</p>
<ul>
<li>学时：48 (讲授 40 + 线上 8)  </li>
<li>期末考试：60%  </li>
<li>栈溢出利用作业：15%  </li>
<li>AFL 的使用作业：15%  </li>
<li>线上学习成绩：10%</li>
</ul>
<h2 id="笔记列表"><a href="#笔记列表" class="headerlink" title="笔记列表"></a>笔记列表</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47102975/article/details/126822398">【软件与系统安全笔记】一、引入_框架主义者的博客-CSDN 博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47102975/article/details/126822467">【软件与系统安全笔记】二、软件与系统安全基础_框架主义者的博客-CSDN 博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47102975/article/details/126822502">【软件与系统安全笔记】三、基础技术_框架主义者的博客-CSDN 博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47102975/article/details/126822598">【软件与系统安全笔记】四、内存破坏漏洞_框架主义者的博客-CSDN 博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47102975/article/details/126822624">【软件与系统安全笔记】五、内存破坏防御_框架主义者的博客-CSDN 博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47102975/article/details/126823172">【软件与系统安全笔记】六、恶意代码的机理及其防护_框架主义者的博客-CSDN 博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47102975/article/details/126823202">【软件与系统安全笔记】七、模糊测试_框架主义者的博客-CSDN 博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47102975/article/details/126823212">【软件与系统安全笔记】八、软件自我保护_框架主义者的博客-CSDN 博客</a></p>
<h2 id="课程资料"><a href="#课程资料" class="headerlink" title="课程资料"></a>课程资料</h2><p><img data-src="https://pic4.zhimg.com/80/v2-17ba13d53e49ec05521c1d8dd16013c1.png" alt="Image"><br>‍</p>
<ul>
<li><a href="assets/intro-20220402190622-3bf68qt.pdf">intro.pdf</a> 课程概述</li>
<li><a href="assets/intro-companion-20220402190622-3bbpkjp.pdf">intro-companion.pdf</a> 软件安全现状（思政内容）</li>
<li><a href="assets/sec-basics-20220402190622-ktie1v7.pdf">sec-basics.pdf</a> 软件与系统安全基础：信任、威胁模型、安全策略与策略执行、通用的安全设计原则</li>
<li><a href="assets/tech_basics-20220402190622-rzsn85q.pdf">tech_basics.pdf</a> 基础技术：x86、内存、寄存器、数据类型、指令集、调用惯例、ELF</li>
<li><a href="assets/attack-surface-20220402190622-utcwoam.pdf">attack-surface.pdf</a></li>
<li><a href="assets/mem-vul-part-20220402201710-svhp3mq.pdf">mem-vul-part.pdf</a> 内存破坏漏洞</li>
</ul>
<p>‍</p>
<h2 id="期末复习重点"><a href="#期末复习重点" class="headerlink" title="期末复习重点"></a>期末复习重点</h2><p>简答题 (70 分）+ 综合题（30 分）</p>
<p>浅灰色不重要：</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-722917acd9a52369595d6b90dc043037.png" alt="Image"></p>
<p><img data-src="https://pic4.zhimg.com/80/v2-523ab6128d6c53d422a732896477d2f2.png" alt="Image"></p>
<ul>
<li><p><del>概述</del></p>
</li>
<li><p>软件与系统安全基础  </p>
<ul>
<li><p>“威胁模型”[^1], <del>可信计算基 (Trusted computing base)</del>,</p>
</li>
<li><p>“安全策略与策略执行”[^2],  <del>通用的安全设计原则</del>, <del>攻击面</del></p>
</li>
<li><p>软件逆向基础：</p>
<ul>
<li>X86 与 x64 体系结构，”x86 概念与内存模型”[^3]</li>
<li><del>二进制文件格式</del></li>
</ul>
</li>
</ul>
</li>
<li><p>软件漏洞利用与防护 </p>
<ul>
<li><p>内存破坏漏洞与防御：”四、内存破坏漏洞”[^4]</p>
<ul>
<li><p>“缓冲区溢出：栈溢出 (stack smashing)”[^8]</p>
</li>
<li><p><del>整数溢出</del>,</p>
</li>
<li><p>“堆溢出”[^9]</p>
<ul>
<li>“Use After Free”[^10]</li>
</ul>
</li>
<li><p><del>Double free, Type Confusion,</del></p>
</li>
<li><p>“格式化字符串攻击”[^11]</p>
</li>
</ul>
</li>
<li><p>高级防御与攻击： “五、内存破坏防御”[^12]</p>
<ul>
<li>“Stack Canaries 栈 金丝雀”[^13]</li>
<li>“数据执行保护 (DEP)”[^14]</li>
<li>代码注入、代码重用  “代码注入 vs 代码重用”[^15]</li>
<li><del>return-to-libc</del></li>
<li>“ASLR Linux 的地址空间布局随机化”[^16]</li>
<li>“ROP 面向返回的编程”[^17]</li>
</ul>
</li>
</ul>
</li>
<li><p>恶意代码的机理及其防护 “六、恶意代码的机理及其防护”[^18]</p>
<ul>
<li><p>病毒，蠕虫，木马，(<strong>侧重：差异，共性，如何隐藏</strong>）</p>
<ul>
<li>“病毒”[^19]</li>
<li>“木马”[^20]</li>
<li>“蠕虫”[^21]</li>
</ul>
</li>
</ul>
</li>
<li><p>模糊测试技术</p>
<ul>
<li>模糊测试（只考偏原理的）, “模糊测试”[^22]</li>
<li><del>AFL 简介，</del></li>
</ul>
</li>
<li><p>软件保护技术 “软件保护技术”<a href="%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF">^23</a></p>
<ul>
<li>“代码混淆”[^24]</li>
<li>“软件防篡改”[^25]</li>
<li>“软件水印，”[^26]</li>
</ul>
</li>
<li><p>渗透测试及其他高级技术（线上）”九、Web 安全”[^27]</p>
<ul>
<li><del>Web 安全</del></li>
<li>SQL 注入 “输入验证：SQL 注入攻击”[^28]</li>
<li>XSS “输入验证：跨站脚本 (XSS, Cross‐Site Scripting)”[^29]</li>
<li><del>渗透测试原理，</del></li>
</ul>
</li>
</ul>
<p>‍</p>
<h3 id="信安班重点"><a href="#信安班重点" class="headerlink" title="信安班重点"></a>信安班重点</h3><ul>
<li>3</li>
</ul>
<p>变量存储位置 </p>
<p>栈的工作原理 </p>
<p>栈溢出、防护技术、DEP，金丝雀</p>
<ul>
<li>4</li>
</ul>
<p>堆的工作原理</p>
<p>堆溢出</p>
<ul>
<li>5</li>
</ul>
<p>整数溢出</p>
<p>格式化字符串漏洞</p>
<ul>
<li>6</li>
</ul>
<p>SQL 注入</p>
<p>数组越界访问漏洞</p>
<ul>
<li>7</li>
</ul>
<p>释放重引用漏洞</p>
<ul>
<li>8</li>
</ul>
<p>绕过 DEP “数据执行保护 (DEP)”[^14]</p>
<p>return to libc    “代码重用攻击：Return to libc”[^30]</p>
<p>返回导向编程 “ROP 面向返回的编程”[^17]</p>
<ul>
<li>9</li>
</ul>
<p><em>返回导向编程：</em>地址空间随机化 “ASLR Linux 的地址空间布局随机化”[^16]</p>
<ul>
<li>10</li>
</ul>
<p><em>Fuzzing</em> 定义、原理、特点</p>
<ul>
<li>11</li>
</ul>
<p>木马实现原理  “木马的实现原理与攻击步骤”[^31]</p>
<ul>
<li>12</li>
</ul>
<p><em>病毒</em></p>
<p>分类”计算机病毒的分类”[^32]</p>
<p>感染目标、过程</p>
<p>隐藏技术 “病毒的隐藏技术”[^33]</p>
<p>花指令</p>
<p>多态 “病毒的多态”[^34]</p>
<ul>
<li>15</li>
</ul>
<p><em>软件自我保护</em></p>
<p>mate 模型 “Man-At-The-End 攻击 (MATE)”[^35]</p>
<p>‍</p>
<br>

<p>‍</p>
<p>‍</p>
<p>[^1]: ## 威胁模型</p>
<pre><code>==威胁模型（Attack model）==：对于影响系统安全的所有信息的结构化表示

本质上, 是从**安全的视角**解读系统与其环境

用于理解攻击者

* 什么**可信**、什么**不可信**
* **攻击者的动机、资源、能力**; **攻击造成的影响**

### 威胁建模

捕获、组织和分析这些影响系统安全的信息的过程

威胁模型使得 &lt;u&gt;结构化地推理&lt;/u&gt; **攻击面** 成为可能

* 确定入口点
* 从攻击者的视角审视系统

  * 分解、识别系统结构
  * 确定各种威胁及其严重程度
  * 确定对策和缓解措施

### 漏洞、攻击与危害

==漏洞(vulnerability)==:可以被对缺陷具有利用能力的攻击者**访问**并**利用**的**缺陷**, 要素:

* 缺陷 (flaw)
* 攻击者能访问缺陷
* 攻击者有利用缺陷的能力

==攻击(attack)==: 指攻击者尝试利用漏洞，例如 主动、被动、DoS...

==危害(compromise)==：攻击成功则危害发生
</code></pre>
<p>[^2]: ## 安全策略与策略执行</p>
<pre><code>==安全策略==

* 允许什么/不允许什么
* 谁被允许做什么

==策略执行==

* 为了安全策略被遵循, 我们要做什么
* 策略执行的方法:利用某些“机制”(mechanism)

  * 说服
  * 监控和威慑
  * 技术上禁止 (这是我们最感兴趣的)
  * 激励管理

**安全策略**是一个系统所应具备的 &lt;u&gt;安全属性 的高层次规约&lt;/u&gt;

**安全策略模型**是安全策略的&lt;u&gt;简明(规范化)描述&lt;/u&gt;

**安全目标**是用户希望通过执行安全策略而获得的东西

**安全属性**与安全目标有时不做严格区分

‍

### 安全策略的 CIA 模型

&gt; 参照 网络与协议安全 中的 CIA 概念
&gt;

* ==机密性==（**C**onfidentiality）
* ==完整性==（**I**ntegrity）
* ==可用性==（**A**vailability）

**其他安全目标：**

隐私(Privacy)

&gt; 可以归类到机密性下
&gt;

非否认性(Non-repudiation), 或可追责性(accountability):防止对消息传送或接收的否认

&gt; 也叫可计量性
&gt;
&gt; 网络与协议安全 中还有 真实性
&gt;

**安全属性的另一种分类方法：**

* Safety 属性:“坏事”不会发生
* Liveness 属性:“好事”终会发生

任何安全属性都可以被分解为一个 safety 属性和一个 liveness 属性

注意:实际上有一些安全策略无法用 safety 属性或 liveness 属性表示, 如信息流策略(2-safety 属性[2])——是“非属性”(Non-Property)
</code></pre>
<p>[^3]: ## x86 概念与内存模型</p>
<pre><code>### 基本概念

x86: 基于 Intel 8086/8088 CPU 的一系列向后兼容的 ISA 的总称

* IA-32: 32 位版本的 x86 指令集体系结构

  * 三种主要操作模式:

    * 实模式 (Real Mode)
    * 保护模式 (Protected Mode)
    * 系统管理模式 (System Management Mode) （大概就是 BIOS 下，对操作系统透明）
* CISC(Complex Instruction Set Computer)体系结构
* x64: 又称 x86-64, 是 x86 的扩展, 是与 x86 兼容的 64 位 ISA

‍

字节序：多字节数据在内存中存储或在网络上传输时各字节的存储/传输顺序

小端序（little endian）：低位字节存储在内存中低位地址, 效率较高(Intel CPU 使用)

大端序（big endian）：低位字节存储在内存中高位地址, 符合思维逻辑。RISC 架构处理器(如 MIPS, PowerPC)采用

‍

### IA-32 内存模型

分段内存模型

程序内存由一系列独立的地址空间（称为“段”）组成。代码、数据和栈在不同的段中

逻辑地址=段选择器 + 偏移量

保护模式下的内存管理:分段（必须）+ 分页（可选）

![Image](https://pic4.zhimg.com/80/v2-4123b01dc37351d208d0b6ad8777a6f3.png)

程序线性地址空间 ≤4GB, 物理地址空间 ≤64GB

每个段最大 232 字节, IA-32 程序最多使用 16383 个段

‍

### x86 Linux 系统的线性地址空间分层

![Image](https://pic4.zhimg.com/80/v2-c06b474f7a6ff8e6d03d343fbe2bc594.png)

![Image](https://pic4.zhimg.com/80/v2-4810107b16d16d7d613bd4909ebc92e1.png)

* [ ] 最大 3G ？

‍
</code></pre>
<p>[^4]: # 四、内存破坏漏洞</p>
<pre><code>2022-03-21 第四次课后半部分

[mem-vul-part.pdf](assets/mem-vul-part-20220402201710-svhp3mq.pdf) 内存破坏漏洞

‍

‍

## 与安全相关的语言问题(C 与 Java 比较)

回顾：

### 漏洞、攻击与危害

==漏洞(vulnerability)==:可以被对缺陷具有利用能力的攻击者**访问**并**利用**的**缺陷**, 要素:

* 缺陷 (flaw)
* 攻击者能访问缺陷
* 攻击者有利用缺陷的能力

==攻击(attack)==: 指攻击者尝试利用漏洞，例如 主动、被动、DoS...

==危害(compromise)==：攻击成功则危害发生

‍

* 软件错误（Software error）：会导致软件无法满足预期的编程错误
* 软件漏洞（Software vulnerability）：可能导致攻击的软件错误

‍

### C 字符串的用法与陷阱

在 C/C++ 程序中, 用 C 语言字符串编程时, 容易出现的错误

* 缓冲区溢出（Buffer overflows）
* Null 终止错误（null-termination errors）
* 差一错误（off-by-one errors）

&gt; 差一错误 是在**计数时由于边界条件判断失误导致结果多了一或少了一的错误**
&gt;

gets:无边界的字符串复制

strcpy 和 strcat

‍

## 缓冲区溢出：栈溢出(stack smashing)

&quot;x86 Linux 系统的线性地址空间分层&quot;[^5]

&quot;System V AMD64 ABI 调用惯例&quot;[^6]

缓冲区溢出可被利用于修改:

* 栈上的: 返回指令指针, 函数指针, 局部变量. . .
* 堆数据结构

覆写返回指令指针

![Image](https://pic4.zhimg.com/80/v2-fdfcf8b1a71a61342726f0ab055f4e2c.png)

**代码注入**

将 ret 设置为被注入代码的起始地址, 被注入代码可以做任何事情,如下载和安装蠕虫

注入 Shell Code

shellcode: 注入的 payload 代码会执行起来一个 shell
在该 shell 中, 攻击者可以执行任何命令
该 shell 与当前进程具有相同的特权级
通常具有 root 权限的进程会被攻击

如何使用被注入的代码调用“execve”?

* 将函数“execve”的地址注入栈上
* “execve”是一个 libc 中的函数, 动态链接到进程地址空间中
* 为了使得我们的可执行程序能够调用 libc 中的函数，可执行程序必须能找到被调用函数的地址

  * 如何做到? 当前程序通过一个 stub（PLT, Procedure Linkage Table ）调用“execve”, PLT 在链接时检索 GOT (Global Offset Table)中的地址集合（请回忆动态链接过程）  
    &quot;劫持全局偏移量表(GOT)中的函数指针, 被动态链接函数所使用&quot;[^7]

‍

‍

## 整数溢出

略

‍

## 堆溢出

&gt; [【NOTES.0x04】简易 Glibc heap exploit 笔记 - arttnba3&#39;s blog](https://arttnba3.cn/2021/05/10/NOTE-0X04-GLIBC_HEAP-EXPLOIT/#)
&gt;

堆溢出: 在堆上开辟的缓冲区中的缓冲区溢出漏洞

溢出发生在堆缓冲区

‍

### 溢出堆上的元数据

Heap allocators (又称内存管理器)

* 哪些内存区域已被开辟，它们的大小
* 哪些内存区域可以被开辟

Heap allocators 维护了元数据 (前块大小, 本块大小, previous 指针, next 指针)

* 堆元数据与堆数据是&lt;u&gt;内联关系&lt;/u&gt;
* 内存管理函数（如 malloc()和 free()）内部，会修改元数据

堆溢出攻击会篡改元数据，并等待内存管理函数把被篡改的元数据写入目标地址

‍

### ==Heap Allocator==

* 维护一个已开辟的块的双向链表，以及一个空闲块的双向链表
* malloc()和 free()会修改双向链表

![Image](https://pic4.zhimg.com/80/v2-964f4a09141157f81e5e4434e7c48c4d.png)

移除一个块

![Image](https://pic4.zhimg.com/80/v2-13d9d0d6efc7a8eb0a79d1fb1defd7a1.png)

### ==攻击 Heap Allocator==

* 通过溢出 chunk2, 攻击者控制 chunk2 的 bk 和 fd 指针

  * 实际上就控制了“向哪儿写数据”(where)以及 “写入什么数据”(what), 可以随意修改堆, 因此又称 “&lt;u&gt;write-what-where&lt;/u&gt;” 漏洞
* 假设攻击者想将 value 写入内存地址 addr

  * 攻击者将 chunk2-&gt;fd 设为 value
  * 攻击者将 chunk2-&gt;bk 设为 addr - offset，其中 offset 为 fd 字段在 chuck 结构体内的偏移量

`free()`:

* chunk2-&gt;bk-&gt;fd = chunk2-&gt;fd
* chunk2-&gt;fd-&gt;bk = chunk2-&gt;bk

变为

* “(addr - offset)-&gt;fd = value”, 等同于`(*addr)=value`
* “value-&gt;bk = addr - offset” （应确保value-&gt;bk有可写权限）

第一个写操作实现了攻击者的目标, 实现了任意的内存写操作

‍

因 &lt;u&gt;write-what-where&lt;/u&gt; 操作由free()完成, 故需从free()向上寻找潜在溢出

当溢出与代码注入/代码重用结合时,

* “`*(addr)=value`”的addr是预先选择的函数指针、返回指令指针、影响控制流的变量地址等, value是恶意的跳转目标
* fd字段在chunk结构体中的偏移量固定
* 因此, 决定被 free 的 chunk2 的元数据 (chunk2-&gt;fd, chunk2-&gt;bk) 应该被溢出修改的取值, 是可计算的

‍

‍

‍

## Use After Free

定义: 程序在堆上释放内存, 然后引用该内存, 就好像该内存位置仍然合法：攻击者可以控制使用已释放的指针进行的数据写入

又称作悬挂指针使用，也是一个 &lt;u&gt;write-what-where&lt;/u&gt; 漏洞

大多数有效的 use-after-free 攻击利用另一类型的数据

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*fnptr)(<span class="keyword">char</span> *arg);</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> B1;</span><br><span class="line">    <span class="keyword">int</span> B2;</span><br><span class="line">    <span class="keyword">char</span> info[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放A, 开辟B, 实际做了什么?</span></span><br><span class="line">x = (struct A *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct A));</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line">y = (struct B *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct B));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何利用此漏洞?</span></span><br><span class="line">y-&gt;B1 = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">x-&gt;fnptr(x-&gt;buf);</span><br></pre></td></tr></table></figure>

&gt; Use-after-free 是类型混淆的一个实例
&gt;

‍

‍

### 禁止 Use After Free

**如何以较简单的方式禁止use-after-free?**

设置所有被释放的堆空间为NULL

这时在使用被释放的堆空间时产生一个 null-pointer dereference

目前, 操作系统对 null-pointer deference 有内建的防护机制

复杂度: 需要设置所有别名指针（aliased pointers）为NULL

‍

‍

## Double Free

略

## 类型混淆

略

## 格式化字符串攻击

能够导致很灵活的恶意利用

* 代码注入: 被注入代码直接放入字符串
* 各种代码重用

`int i; printf (“i = %d with address %08x\n&quot;, i, &amp;i);`

将格式化字符串的地址指针,  `i` 和 `&amp;i` 分别通过寄存器 rdi, rsi 和 rdx 传递, 并调用 `printf`

当程序运行至printf内部, 会在这些寄存器中查找参数；如果参数超过6个，还会在栈上查找参数

格式指示符字母的含义: [printf - C++ Reference (cplusplus.com)](https://cplusplus.com/reference/cstdio/printf/)

![Image](https://pic4.zhimg.com/80/v2-9a10d2826a9cfe71853033eafde1809a.png)

![image.png](assets/image-20220622134039-5re4d9e.png)

### **格式化字符串中的“`%n`”**

能够将到“%n”位置为止已经由printf打印出的字节数写到一个我们选定的变量中

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;foobar%n\n&quot;</span>, (<span class="keyword">int</span> *) &amp;i);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"><span class="comment">// i 的值最终为6</span></span><br></pre></td></tr></table></figure>

对于“format-string.c”程序, 如果用户输入“foobar%n”会怎样?

* 从rsi获得一个地址, 且向该地址上的内存单元中写入整数6
* 如果输入的是“foobar%10u%n”呢? 可能会向该内存位置写入16
* 如何向一个任意地址写? 将该地址放在正确的位置 (寄存器或栈单元, 以作为printf的参数)

因此, 攻击者可以用任意内容更新任意内存。可否覆写一个函数指针并劫持控制流(且安装某些蠕虫代码)?

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>); <span class="comment">// no buffer overflow here</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The input is:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf); <span class="comment">// format string attacks here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

==攻击者可以==

* 查看/修改内存的任意部分
* 执行任意代码, 只需要把代码也放入buf

‍

### 格式化字符串攻击的修复

![Image](https://pic4.zhimg.com/80/v2-572ae7966dca24d6c45b613ca3c111c1.png)

![Image](https://pic4.zhimg.com/80/v2-82c920644c9900740c009f55d8e1a03a.png)

通过提供一个特殊的格式化字符串, 可以规避“`%400s`”的限制：

“`%497d\x3c\xd3\xff\xbf&lt;nops&gt;&lt;shellcode&gt;`”。创建一个497字符长的字符串，加上错误字符串(“ERR Wrong command: ”),超过了outbuf的长度4字节。虽然“user”字符串只允许 400字节,可以通过滥用格式化字符串参数扩展其长度。因为第二个`sprintf`不检查长度, 它可以用来突破outbuf的长度界限。此时我们写入了一个返回地址 (`0xbfffd33c`), 并可以以之前栈溢出的利用方式进行攻击

‍

### 防止格式化字符串漏洞

即限制攻击者控制格式化字符串的能力

* 如果有可能，硬编码字符串；且不用包含“`%*`”的格式化字符串
* 如果必须要用格式化字符串，至少不要用“`printf(arg)`”
* 不要使用 `%n`
* 小心其他的引用: `%s` 和 `sprintf` 能够被用于构造栈内容披露攻击
* 编译器支持printf参数与格式化字符串的匹配检查

‍
</code></pre>
<p>[^5]: ### x86 Linux 系统的线性地址空间分层</p>
<pre><code>![Image](https://pic4.zhimg.com/80/v2-c06b474f7a6ff8e6d03d343fbe2bc594.png)

![Image](https://pic4.zhimg.com/80/v2-4810107b16d16d7d613bd4909ebc92e1.png)

* [ ] 最大 3G ？

‍
</code></pre>
<p>[^6]: System V AMD64 ABI 调用惯例</p>
<p>[^7]: 劫持全局偏移量表 (GOT) 中的函数指针，被动态链接函数所使用</p>
<p>[^8]: ## 缓冲区溢出：栈溢出 (stack smashing)</p>
<pre><code>&quot;x86 Linux 系统的线性地址空间分层&quot;[^5]

&quot;System V AMD64 ABI 调用惯例&quot;[^6]

缓冲区溢出可被利用于修改:

* 栈上的: 返回指令指针, 函数指针, 局部变量. . .
* 堆数据结构

覆写返回指令指针

![Image](https://pic4.zhimg.com/80/v2-fdfcf8b1a71a61342726f0ab055f4e2c.png)

**代码注入**

将 ret 设置为被注入代码的起始地址, 被注入代码可以做任何事情,如下载和安装蠕虫

注入 Shell Code

shellcode: 注入的 payload 代码会执行起来一个 shell
在该 shell 中, 攻击者可以执行任何命令
该 shell 与当前进程具有相同的特权级
通常具有 root 权限的进程会被攻击

如何使用被注入的代码调用“execve”?

* 将函数“execve”的地址注入栈上
* “execve”是一个 libc 中的函数, 动态链接到进程地址空间中
* 为了使得我们的可执行程序能够调用 libc 中的函数，可执行程序必须能找到被调用函数的地址

  * 如何做到? 当前程序通过一个 stub（PLT, Procedure Linkage Table ）调用“execve”, PLT 在链接时检索 GOT (Global Offset Table)中的地址集合（请回忆动态链接过程）  
    &quot;劫持全局偏移量表(GOT)中的函数指针, 被动态链接函数所使用&quot;[^7]

‍

‍
</code></pre>
<p>[^9]: ## 堆溢出</p>
<pre><code>&gt; [【NOTES.0x04】简易 Glibc heap exploit 笔记 - arttnba3&#39;s blog](https://arttnba3.cn/2021/05/10/NOTE-0X04-GLIBC_HEAP-EXPLOIT/#)
&gt;

堆溢出: 在堆上开辟的缓冲区中的缓冲区溢出漏洞

溢出发生在堆缓冲区

‍

### 溢出堆上的元数据

Heap allocators (又称内存管理器)

* 哪些内存区域已被开辟，它们的大小
* 哪些内存区域可以被开辟

Heap allocators 维护了元数据 (前块大小, 本块大小, previous 指针, next 指针)

* 堆元数据与堆数据是&lt;u&gt;内联关系&lt;/u&gt;
* 内存管理函数（如 malloc()和 free()）内部，会修改元数据

堆溢出攻击会篡改元数据，并等待内存管理函数把被篡改的元数据写入目标地址

‍

### ==Heap Allocator==

* 维护一个已开辟的块的双向链表，以及一个空闲块的双向链表
* malloc()和 free()会修改双向链表

![Image](https://pic4.zhimg.com/80/v2-964f4a09141157f81e5e4434e7c48c4d.png)

移除一个块

![Image](https://pic4.zhimg.com/80/v2-13d9d0d6efc7a8eb0a79d1fb1defd7a1.png)

### ==攻击 Heap Allocator==

* 通过溢出 chunk2, 攻击者控制 chunk2 的 bk 和 fd 指针

  * 实际上就控制了“向哪儿写数据”(where)以及 “写入什么数据”(what), 可以随意修改堆, 因此又称 “&lt;u&gt;write-what-where&lt;/u&gt;” 漏洞
* 假设攻击者想将 value 写入内存地址 addr

  * 攻击者将 chunk2-&gt;fd 设为 value
  * 攻击者将 chunk2-&gt;bk 设为 addr - offset，其中 offset 为 fd 字段在 chuck 结构体内的偏移量

`free()`:

* chunk2-&gt;bk-&gt;fd = chunk2-&gt;fd
* chunk2-&gt;fd-&gt;bk = chunk2-&gt;bk

变为

* “(addr - offset)-&gt;fd = value”, 等同于`(*addr)=value`
* “value-&gt;bk = addr - offset” （应确保value-&gt;bk有可写权限）

第一个写操作实现了攻击者的目标, 实现了任意的内存写操作

‍

因 &lt;u&gt;write-what-where&lt;/u&gt; 操作由free()完成, 故需从free()向上寻找潜在溢出

当溢出与代码注入/代码重用结合时,

* “`*(addr)=value`”的addr是预先选择的函数指针、返回指令指针、影响控制流的变量地址等, value是恶意的跳转目标
* fd字段在chunk结构体中的偏移量固定
* 因此, 决定被 free 的 chunk2 的元数据 (chunk2-&gt;fd, chunk2-&gt;bk) 应该被溢出修改的取值, 是可计算的

‍

‍

‍
</code></pre>
<p>[^10]: ## Use After Free</p>
<pre><code>定义: 程序在堆上释放内存, 然后引用该内存, 就好像该内存位置仍然合法：攻击者可以控制使用已释放的指针进行的数据写入

又称作悬挂指针使用，也是一个 &lt;u&gt;write-what-where&lt;/u&gt; 漏洞

大多数有效的 use-after-free 攻击利用另一类型的数据

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*fnptr)(<span class="keyword">char</span> *arg);</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> B1;</span><br><span class="line">    <span class="keyword">int</span> B2;</span><br><span class="line">    <span class="keyword">char</span> info[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放A, 开辟B, 实际做了什么?</span></span><br><span class="line">x = (struct A *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct A));</span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line">y = (struct B *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct B));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何利用此漏洞?</span></span><br><span class="line">y-&gt;B1 = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">x-&gt;fnptr(x-&gt;buf);</span><br></pre></td></tr></table></figure>

&gt; Use-after-free 是类型混淆的一个实例
&gt;

‍

‍

### 禁止 Use After Free

**如何以较简单的方式禁止use-after-free?**

设置所有被释放的堆空间为NULL

这时在使用被释放的堆空间时产生一个 null-pointer dereference

目前, 操作系统对 null-pointer deference 有内建的防护机制

复杂度: 需要设置所有别名指针（aliased pointers）为NULL

‍

‍
</code></pre>
<p>[^11]: ## 格式化字符串攻击</p>
<pre><code>能够导致很灵活的恶意利用

* 代码注入: 被注入代码直接放入字符串
* 各种代码重用

`int i; printf (“i = %d with address %08x\n&quot;, i, &amp;i);`

将格式化字符串的地址指针,  `i` 和 `&amp;i` 分别通过寄存器 rdi, rsi 和 rdx 传递, 并调用 `printf`

当程序运行至printf内部, 会在这些寄存器中查找参数；如果参数超过6个，还会在栈上查找参数

格式指示符字母的含义: [printf - C++ Reference (cplusplus.com)](https://cplusplus.com/reference/cstdio/printf/)

![image.png](assets/image-20220622134033-770sl8v.png)

![image.png](assets/image-20220622134039-5re4d9e.png)

### **格式化字符串中的“`%n`”**

能够将到“%n”位置为止已经由printf打印出的字节数写到一个我们选定的变量中

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;foobar%n\n&quot;</span>, (<span class="keyword">int</span> *) &amp;i);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"><span class="comment">// i 的值最终为6</span></span><br></pre></td></tr></table></figure>

对于“format-string.c”程序, 如果用户输入“foobar%n”会怎样?

* 从rsi获得一个地址, 且向该地址上的内存单元中写入整数6
* 如果输入的是“foobar%10u%n”呢? 可能会向该内存位置写入16
* 如何向一个任意地址写? 将该地址放在正确的位置 (寄存器或栈单元, 以作为printf的参数)

因此, 攻击者可以用任意内容更新任意内存。可否覆写一个函数指针并劫持控制流(且安装某些蠕虫代码)?

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>); <span class="comment">// no buffer overflow here</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The input is:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf); <span class="comment">// format string attacks here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

==攻击者可以==

* 查看/修改内存的任意部分
* 执行任意代码, 只需要把代码也放入buf

‍

### 格式化字符串攻击的修复

![Image](https://pic4.zhimg.com/80/v2-572ae7966dca24d6c45b613ca3c111c1.png)

![Image](https://pic4.zhimg.com/80/v2-82c920644c9900740c009f55d8e1a03a.png)

通过提供一个特殊的格式化字符串, 可以规避“`%400s`”的限制：

“`%497d\x3c\xd3\xff\xbf&lt;nops&gt;&lt;shellcode&gt;`”。创建一个497字符长的字符串，加上错误字符串(“ERR Wrong command: ”),超过了outbuf的长度4字节。虽然“user”字符串只允许 400字节,可以通过滥用格式化字符串参数扩展其长度。因为第二个`sprintf`不检查长度, 它可以用来突破outbuf的长度界限。此时我们写入了一个返回地址 (`0xbfffd33c`), 并可以以之前栈溢出的利用方式进行攻击

‍

### 防止格式化字符串漏洞

即限制攻击者控制格式化字符串的能力

* 如果有可能，硬编码字符串；且不用包含“`%*`”的格式化字符串
* 如果必须要用格式化字符串，至少不要用“`printf(arg)`”
* 不要使用 `%n`
* 小心其他的引用: `%s` 和 `sprintf` 能够被用于构造栈内容披露攻击
* 编译器支持printf参数与格式化字符串的匹配检查

‍
</code></pre>
<p>[^12]: # 五、内存破坏防御</p>
<pre><code>虽然对缓冲区溢出的认知已超过 40 年之久, 但缓冲区溢出仍未被消除。部分原因在于存在大量的利用选项：

* 多样的目标: 不仅仅可以利用返回地址, 实际上可以利用任意代码地址或数据
* 多样的使用: 可以利用“读”或“写”操作
* 多样的利用方式: 对代码可以“注入”或“重用”
* 当前对溢出的防御措施多样, 但不完全

**防御可以在不同的时机进行**

* 编程前
* 开发过程中 (防御性编程)
* 测试时 (fuzzing, . . .)
* 代码运行时 (检测和缓解: stack canaries, DEP, . . .)

‍

## **Stack Canaries** 栈 金丝雀

是栈溢出的检测机制, 又称“栈 cookies”，由 gcc 的 StackGuard 实现

原理：将一个 dummy 值(或随机值)写到栈上的返回地址之前,并在函数返回时检查该值。不小心构造的栈溢出(假定是顺序栈粉碎)会覆写该“canary”单元, 该行为将被探测到。

### 攻破 StackGuard 的基本方法

对 canary 单元, 用正确的值覆写

* 如果 canary 所使用的随机值范围很小, 则枚举每种可能性
* 或先实施一个 memory disclosure 攻击, 获知 canary 的值

无法抵御 disclosure 攻击是 StackGuard 的最大局限性

* disclosure 攻击通过对缓冲区的“overread”实现
* 著名例子: 对 SSL 的 Heartbleed 攻击
* 以下程序为什么会对 Stackguard 的 canaries 造成威胁?

  * 通过对缓冲区的“overread”, 攻击者读取超出栈缓冲区之外的值, 从而获取 canary 的值

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> packet[<span class="number">10</span>];</span><br><span class="line">…</span><br><span class="line"><span class="comment">// suppose len is adversary controlled</span></span><br><span class="line"><span class="built_in">strncpy</span>(buf, packet, len);</span><br><span class="line">send(fd, buf, len);</span><br></pre></td></tr></table></figure>

![Image](https://pic4.zhimg.com/80/v2-ffcb435eb84eb778e7734c852d1b86dc.png)

有时不需要覆写返回地址, 可以溢出:

* 安全敏感的局部变量
* 堆数据
* 全局数据
* · · ·
* 本质上, 攻击者只需要劫持一个函数指针

### 劫持函数指针

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span> <span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf [<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">void</span> (*f) () = &amp;foo;</span><br><span class="line">    gets(buf);</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

假定我们没有机会溢出返回地址

可溢出缓冲区, 使得函数指针被修改为 bar 的地址, 然后函数调用将调用 bar 而非 foo

**劫持函数指针的其他方法**

* 使用堆溢出，对堆上的函数指针进行劫持
* 劫持全局函数指针
* 劫持全局偏移量表(GOT)中的函数指针, 被动态链接函数所使用

‍

### 攻破 StackGuard 的其他方法

有时不需要覆写返回地址, 可以溢出:

* 安全敏感的局部变量
* 堆数据
* 全局数据

  * 全局数据溢出: 攻击位于全局数据区的缓冲区
* · · ·

如何防御?

* 让函数指针位于其他类型数据的下方(更低地址)
* 在全局数据区和其他管理表结构之间使用**守卫页**

### 守卫页(Guard Pages)

也是一种运行时检测方法, 可以看作StackGuard的扩展

在一个进程地址空间中关键内存区域之间放置守卫页 (像一些gaps)

* 需借助CPU内存管理单元(MMU)的管理功能将它们标记为非法地址
* 任何对其的访问尝试都导致进程被终止

效果: 能失效缓冲区溢出攻击, 特别是对全局数据区的溢出攻击

甚至可以在栈帧之间、或者堆缓冲区之间放置守卫页

* 可以提供更进一步的保护, 防止栈溢出和堆溢出攻击
* 会导致执行时间和内存的很大开销, 因为要支持大量页映射

‍

‍

## 数据执行保护(DEP)

冯诺依曼体系结构

* 将代码作为数据存储
* 使得攻击者可以向栈或堆注入代码, 而栈和堆原本只应该存储数据

哈佛架构

* 虚拟地址空间切分为一个数据区和一个代码区
* 代码区可读且可执行
* 数据区可读且可写
* 没有区域是既可写又可执行的

**Data Execution Prevention （数据执行保护）: 是一种运行时缓解技术**

DEP又称作Nx-bit (non executable bit), W**⊕**X

能够阻止代码注入攻击

很多缓冲区溢出攻击涉及将机器码复制到目标缓冲区, 然后将执行转移到这些缓冲区

* 一种防御方法就是阻止在栈/堆/全局数据区中执行代码, 并假定可执行代码只能出现在进程地址空间中除这些位置外的其他位置需要CPU内存管理单元(MMU)提供支持, 将虚拟内存的对应页标记为不可执行
* 对于每一个被映射的虚拟内存页, 都有这样额外的1个no-executebit, 置位时, 表示该页的数据不能作为代码执行, 一旦程序控制流到达该页, CPU会产生陷入

DEP 被绝大多数操作系统和指令集体系结构支持

* 一些CPU早有支持(如Solaris的SPARC), 只需修改Solaris内核参数即可启用
* x86系列后来才向MMU中加入no-execute位
* Linux/Unix类系统, Windows均已提供相应扩展, 支持使用DEP特性

对 Nx-bit 的不同叫法

* Intel: XD (eXecute Disable)
* AMD: Enhanced Virus Protection
* ARM: XN (eXecute Never)

如果CPU硬件支持, DEP可作为操作系统更新, 通过更改对进程虚拟地址空间的内存管理, 提供对现有漏洞程序的保护

DEP将栈和堆置为不可执行, 对多种缓冲区溢出攻击提供了一种高度的保护

但有一些合法程序需要将可执行代码放在栈上：

* 如Java运行时系统、运行时代码生成、Linux信号处理程序等
* 需要针对这些需求制定一些专门条款(Special provisions)

‍

### 攻击 DEP——代码重用攻击

**思路: 重用程序自身的代码**

Return-to-libc: 用危险的库函数的地址替换返回地址
</code></pre>
<p>​      </p>
<pre><code>#### 代码重用攻击: Return to libc

危险库函数如 `system()`

攻击者构造合适的参数(在栈上, 返回指令指针的上方)

* 在x64架构上，还需要更多的工作：设置参数传递寄存器的值

函数返回，库函数得到执行

* 例如：`execve(“/bin/sh”)`

甚至可以链接两个库函数调用

![Image](https://pic4.zhimg.com/80/v2-b4e0c7bbb9ddb981becbd303bda1dd9f.png)

‍

==**具体地**==

* 攻击者用一个溢出填充buffer:

  * 更改栈上保存的ebp为一个合适地址
  * 更改返回指令指针为一个欲执行的库函数的地址
  * 写一个占位符值(库函数会认为其是返回地址,如果想利用它调用第二个库函数, 应写入第二个库函数的地址)
  * 写一个或多个要传递给此库函数的参数
* 当被攻击的函数返回时, 恢复(更改过的)ebp, 然后pop更改后的返回地址到eip, 从而开始执行库函数代码
* 因为库函数相信它已被调用, 故会将栈顶当前值(占位符)作为它自己栈帧的返回指令指针, 之上是参数
* 最终会在占位符位置的下方创建起一个新的栈帧 (对应于库函数的执行)
* 根据库函数参数类型以及库函数对参数的解释方式, 攻击者可能需要准确地知道参数地址以做溢出写

‍

### 代码注入 vs 代码重用

![Image](https://pic4.zhimg.com/80/v2-7b201cd40719564835bef0751fd4eebc.png)

**代码重用与代码注入的协同**

在很多攻击中, 代码重用攻击用来作为禁用DEP的第一步

* 目标是允许对栈内存进行执行
* 有一个系统调用可以更改栈的读/写/执行属性

  * int mprotect(void *addr, size_t len, int prot);
* 设置对于起始于addr的内存区域的保护
* 调用此系统调用, 允许在栈上的“执行”属性, 然后开始执行被注入的代码

‍

‍

## ROP 面向返回的编程

面向返回的编程

* 执行任意行为, 不需要注入代码
* 联合现有的==代码片段 (gadgets)==
* 一系列图灵完全的 gadgets, 及一种串联这些 gadgets 的方法
* 现有的展示已能针对小程序(如16KB)找到图灵完全的 gadgets 集合

![Image](https://pic4.zhimg.com/80/v2-ba3354f29ca5d131bd8253c0b82f6346.png)

**正常机器指令序列**

![Image](https://pic4.zhimg.com/80/v2-69d2f5865e2be7a7c532648b1182f8ea.png)

**ROP执行**

![Image](https://pic4.zhimg.com/80/v2-f2cfca551d5cc0091ed53e5b114b2178.png)

==TODO==

### 用ROP我们能做什么?

Turing completeness

一种语言是Turing complete的，如果其具有

* 条件分支（Conditional branching）
* 可以任意修改内存

这两点在ROP中均能实现

### **针对ROP的保护**

ROP的工作基于对程序控制流的修改

控制流完整性 (Control-flow integrity, CFI)

* 预先决定被攻击程序的控制流图
* 向该程序中插入检测, 使得在程序运行时发生非法控制流跳转时,终止程序

  * 通过编译器或二进制重写进行插入

‍

### ROP 的运行时缓解: 随机化

ROP利用要求攻击者对代码/数据地址的知识，例如

* 缓冲区的起始地址
* 库函数的地址

思路: 引入人为的多样性(随机化)

* 使得地址对于攻击者而言难以预测
* 如果攻击者不知道一段代码(或数据)在内存的什么位置,
* 他就没办法在攻击中重用它们

有很多方法能够实现随机化

* 对栈的位置进行随机化, 对堆上的关键数据结构进行随机化,
* 对库函数的位置进行随机化
* 随机地填充栈帧
* 在编译时, 随机化代码生成, 以抵御 ROP

实现随机化的时机

* 编译时
* 链接时
* 运行时(通过动态二进制重写, dynamic binary rewriting)

地址空间随机化的挑战

* 信息泄露(如通过边信道)
* 暴力破解秘密值
* 对于长时间运行的进程, 如何“再次随机化”

地址空间随机化的有效性取决于

* 每个被随机出的位置的熵值
* 随机化的完备性(completeness), 例如是否所有的对象都被随机化?
* 信息泄露的避免程度

‍

‍

### ASLR Linux 的地址空间布局随机化

ASLR（Address space layout randomization）

* 对于位置无关的可执行程序(PIE), 随机化该可执行程序的基地址

  * 所有库都是 PIE, 因此它们的基地址被随机化
  * 主可执行程序可能不是 PIE, 故可能无法被 ASLR 保护
* 关注的是内存块的随机化
* ASLR 是一种粗粒度的随机化形式

  * 只有基地址被随机化
  * 在内存对象之间的相对距离不变

**攻破 ASLR 的方法**

* 如果随机地址空间很小, 可以进行一个穷举搜索

  * 例如, Linux 提供 16 位的随机化强度, 可以在约 200 秒以内被穷举搜索攻破
* ASLR 经常被 memory disclosure （内存泄漏） 攻破

  * 例如, 如果攻击者可以读取指向栈的指针值, 他就可以使用该指针值发现栈在哪里

‍

‍

## 防御性编程

### 使用更安全的编程语言

### 代码评审

‍

费根检查（fagan inspection）

检查表

### 编译时防御

‍

### 编写时

危险的 C 库函数

‍

### 输入验证

所有输入都是恶意的

最小化攻击面

识别攻击面

‍

### 防御性编程总结

* 好的实践

  * 使用更安全的编程语言
  * 进行代码评审
  * 使用编译器的机制, 如 StackGuard
  * 编写内存安全的代码

    * 使用边界检查库函数，使用更安全的库
* 输入验证

  * 识别攻击面: 程序从信道获得输入
  * 最小化攻击面
  * 将所有输入都看作潜在恶意的

‍
</code></pre>
<p>[^13]: ## <strong>Stack Canaries</strong> 栈 金丝雀</p>
<pre><code>是栈溢出的检测机制, 又称“栈 cookies”，由 gcc 的 StackGuard 实现

原理：将一个 dummy 值(或随机值)写到栈上的返回地址之前,并在函数返回时检查该值。不小心构造的栈溢出(假定是顺序栈粉碎)会覆写该“canary”单元, 该行为将被探测到。

### 攻破 StackGuard 的基本方法

对 canary 单元, 用正确的值覆写

* 如果 canary 所使用的随机值范围很小, 则枚举每种可能性
* 或先实施一个 memory disclosure 攻击, 获知 canary 的值

无法抵御 disclosure 攻击是 StackGuard 的最大局限性

* disclosure 攻击通过对缓冲区的“overread”实现
* 著名例子: 对 SSL 的 Heartbleed 攻击
* 以下程序为什么会对 Stackguard 的 canaries 造成威胁?

  * 通过对缓冲区的“overread”, 攻击者读取超出栈缓冲区之外的值, 从而获取 canary 的值

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> packet[<span class="number">10</span>];</span><br><span class="line">…</span><br><span class="line"><span class="comment">// suppose len is adversary controlled</span></span><br><span class="line"><span class="built_in">strncpy</span>(buf, packet, len);</span><br><span class="line">send(fd, buf, len);</span><br></pre></td></tr></table></figure>

![Image](https://pic4.zhimg.com/80/v2-ffcb435eb84eb778e7734c852d1b86dc.png)

有时不需要覆写返回地址, 可以溢出:

* 安全敏感的局部变量
* 堆数据
* 全局数据
* · · ·
* 本质上, 攻击者只需要劫持一个函数指针

### 劫持函数指针

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span> <span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf [<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">void</span> (*f) () = &amp;foo;</span><br><span class="line">    gets(buf);</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

假定我们没有机会溢出返回地址

可溢出缓冲区, 使得函数指针被修改为 bar 的地址, 然后函数调用将调用 bar 而非 foo

**劫持函数指针的其他方法**

* 使用堆溢出，对堆上的函数指针进行劫持
* 劫持全局函数指针
* 劫持全局偏移量表(GOT)中的函数指针, 被动态链接函数所使用

‍

### 攻破 StackGuard 的其他方法

有时不需要覆写返回地址, 可以溢出:

* 安全敏感的局部变量
* 堆数据
* 全局数据

  * 全局数据溢出: 攻击位于全局数据区的缓冲区
* · · ·

如何防御?

* 让函数指针位于其他类型数据的下方(更低地址)
* 在全局数据区和其他管理表结构之间使用**守卫页**

### 守卫页(Guard Pages)

也是一种运行时检测方法, 可以看作StackGuard的扩展

在一个进程地址空间中关键内存区域之间放置守卫页 (像一些gaps)

* 需借助CPU内存管理单元(MMU)的管理功能将它们标记为非法地址
* 任何对其的访问尝试都导致进程被终止

效果: 能失效缓冲区溢出攻击, 特别是对全局数据区的溢出攻击

甚至可以在栈帧之间、或者堆缓冲区之间放置守卫页

* 可以提供更进一步的保护, 防止栈溢出和堆溢出攻击
* 会导致执行时间和内存的很大开销, 因为要支持大量页映射

‍

‍
</code></pre>
<p>[^14]: ## 数据执行保护 (DEP)</p>
<pre><code>冯诺依曼体系结构

* 将代码作为数据存储
* 使得攻击者可以向栈或堆注入代码, 而栈和堆原本只应该存储数据

哈佛架构

* 虚拟地址空间切分为一个数据区和一个代码区
* 代码区可读且可执行
* 数据区可读且可写
* 没有区域是既可写又可执行的

**Data Execution Prevention （数据执行保护）: 是一种运行时缓解技术**

DEP又称作Nx-bit (non executable bit), W**⊕**X

能够阻止代码注入攻击

很多缓冲区溢出攻击涉及将机器码复制到目标缓冲区, 然后将执行转移到这些缓冲区

* 一种防御方法就是阻止在栈/堆/全局数据区中执行代码, 并假定可执行代码只能出现在进程地址空间中除这些位置外的其他位置需要CPU内存管理单元(MMU)提供支持, 将虚拟内存的对应页标记为不可执行
* 对于每一个被映射的虚拟内存页, 都有这样额外的1个no-executebit, 置位时, 表示该页的数据不能作为代码执行, 一旦程序控制流到达该页, CPU会产生陷入

DEP 被绝大多数操作系统和指令集体系结构支持

* 一些CPU早有支持(如Solaris的SPARC), 只需修改Solaris内核参数即可启用
* x86系列后来才向MMU中加入no-execute位
* Linux/Unix类系统, Windows均已提供相应扩展, 支持使用DEP特性

对 Nx-bit 的不同叫法

* Intel: XD (eXecute Disable)
* AMD: Enhanced Virus Protection
* ARM: XN (eXecute Never)

如果CPU硬件支持, DEP可作为操作系统更新, 通过更改对进程虚拟地址空间的内存管理, 提供对现有漏洞程序的保护

DEP将栈和堆置为不可执行, 对多种缓冲区溢出攻击提供了一种高度的保护

但有一些合法程序需要将可执行代码放在栈上：

* 如Java运行时系统、运行时代码生成、Linux信号处理程序等
* 需要针对这些需求制定一些专门条款(Special provisions)

‍

### 攻击 DEP——代码重用攻击

**思路: 重用程序自身的代码**

Return-to-libc: 用危险的库函数的地址替换返回地址
</code></pre>
<p>​      </p>
<pre><code>#### 代码重用攻击: Return to libc

危险库函数如 `system()`

攻击者构造合适的参数(在栈上, 返回指令指针的上方)

* 在x64架构上，还需要更多的工作：设置参数传递寄存器的值

函数返回，库函数得到执行

* 例如：`execve(“/bin/sh”)`

甚至可以链接两个库函数调用

![Image](https://pic4.zhimg.com/80/v2-b4e0c7bbb9ddb981becbd303bda1dd9f.png)

‍

==**具体地**==

* 攻击者用一个溢出填充buffer:

  * 更改栈上保存的ebp为一个合适地址
  * 更改返回指令指针为一个欲执行的库函数的地址
  * 写一个占位符值(库函数会认为其是返回地址,如果想利用它调用第二个库函数, 应写入第二个库函数的地址)
  * 写一个或多个要传递给此库函数的参数
* 当被攻击的函数返回时, 恢复(更改过的)ebp, 然后pop更改后的返回地址到eip, 从而开始执行库函数代码
* 因为库函数相信它已被调用, 故会将栈顶当前值(占位符)作为它自己栈帧的返回指令指针, 之上是参数
* 最终会在占位符位置的下方创建起一个新的栈帧 (对应于库函数的执行)
* 根据库函数参数类型以及库函数对参数的解释方式, 攻击者可能需要准确地知道参数地址以做溢出写

‍

### 代码注入 vs 代码重用

![Image](https://pic4.zhimg.com/80/v2-7b201cd40719564835bef0751fd4eebc.png)

**代码重用与代码注入的协同**

在很多攻击中, 代码重用攻击用来作为禁用DEP的第一步

* 目标是允许对栈内存进行执行
* 有一个系统调用可以更改栈的读/写/执行属性

  * int mprotect(void *addr, size_t len, int prot);
* 设置对于起始于addr的内存区域的保护
* 调用此系统调用, 允许在栈上的“执行”属性, 然后开始执行被注入的代码

‍

‍
</code></pre>
<p>[^15]: ### 代码注入 vs 代码重用</p>
<pre><code>![Image](https://pic4.zhimg.com/80/v2-7b201cd40719564835bef0751fd4eebc.png)

**代码重用与代码注入的协同**

在很多攻击中, 代码重用攻击用来作为禁用DEP的第一步

* 目标是允许对栈内存进行执行
* 有一个系统调用可以更改栈的读/写/执行属性

  * int mprotect(void *addr, size_t len, int prot);
* 设置对于起始于addr的内存区域的保护
* 调用此系统调用, 允许在栈上的“执行”属性, 然后开始执行被注入的代码

‍

‍
</code></pre>
<p>[^16]: ### ASLR Linux 的地址空间布局随机化</p>
<pre><code>ASLR（Address space layout randomization）

* 对于位置无关的可执行程序(PIE), 随机化该可执行程序的基地址

  * 所有库都是 PIE, 因此它们的基地址被随机化
  * 主可执行程序可能不是 PIE, 故可能无法被 ASLR 保护
* 关注的是内存块的随机化
* ASLR 是一种粗粒度的随机化形式

  * 只有基地址被随机化
  * 在内存对象之间的相对距离不变

**攻破 ASLR 的方法**

* 如果随机地址空间很小, 可以进行一个穷举搜索

  * 例如, Linux 提供 16 位的随机化强度, 可以在约 200 秒以内被穷举搜索攻破
* ASLR 经常被 memory disclosure （内存泄漏） 攻破

  * 例如, 如果攻击者可以读取指向栈的指针值, 他就可以使用该指针值发现栈在哪里

‍

‍
</code></pre>
<p>[^17]: ## ROP 面向返回的编程</p>
<pre><code>面向返回的编程

* 执行任意行为, 不需要注入代码
* 联合现有的==代码片段 (gadgets)==
* 一系列图灵完全的 gadgets, 及一种串联这些 gadgets 的方法
* 现有的展示已能针对小程序(如16KB)找到图灵完全的 gadgets 集合

![Image](https://pic4.zhimg.com/80/v2-ba3354f29ca5d131bd8253c0b82f6346.png)

**正常机器指令序列**

![Image](https://pic4.zhimg.com/80/v2-69d2f5865e2be7a7c532648b1182f8ea.png)

**ROP执行**

![Image](https://pic4.zhimg.com/80/v2-f2cfca551d5cc0091ed53e5b114b2178.png)

==TODO==

### 用ROP我们能做什么?

Turing completeness

一种语言是Turing complete的，如果其具有

* 条件分支（Conditional branching）
* 可以任意修改内存

这两点在ROP中均能实现

### **针对ROP的保护**

ROP的工作基于对程序控制流的修改

控制流完整性 (Control-flow integrity, CFI)

* 预先决定被攻击程序的控制流图
* 向该程序中插入检测, 使得在程序运行时发生非法控制流跳转时,终止程序

  * 通过编译器或二进制重写进行插入

‍

### ROP 的运行时缓解: 随机化

ROP利用要求攻击者对代码/数据地址的知识，例如

* 缓冲区的起始地址
* 库函数的地址

思路: 引入人为的多样性(随机化)

* 使得地址对于攻击者而言难以预测
* 如果攻击者不知道一段代码(或数据)在内存的什么位置,
* 他就没办法在攻击中重用它们

有很多方法能够实现随机化

* 对栈的位置进行随机化, 对堆上的关键数据结构进行随机化,
* 对库函数的位置进行随机化
* 随机地填充栈帧
* 在编译时, 随机化代码生成, 以抵御 ROP

实现随机化的时机

* 编译时
* 链接时
* 运行时(通过动态二进制重写, dynamic binary rewriting)

地址空间随机化的挑战

* 信息泄露(如通过边信道)
* 暴力破解秘密值
* 对于长时间运行的进程, 如何“再次随机化”

地址空间随机化的有效性取决于

* 每个被随机出的位置的熵值
* 随机化的完备性(completeness), 例如是否所有的对象都被随机化?
* 信息泄露的避免程度

‍

‍

### ASLR Linux 的地址空间布局随机化

ASLR（Address space layout randomization）

* 对于位置无关的可执行程序(PIE), 随机化该可执行程序的基地址

  * 所有库都是 PIE, 因此它们的基地址被随机化
  * 主可执行程序可能不是 PIE, 故可能无法被 ASLR 保护
* 关注的是内存块的随机化
* ASLR 是一种粗粒度的随机化形式

  * 只有基地址被随机化
  * 在内存对象之间的相对距离不变

**攻破 ASLR 的方法**

* 如果随机地址空间很小, 可以进行一个穷举搜索

  * 例如, Linux 提供 16 位的随机化强度, 可以在约 200 秒以内被穷举搜索攻破
* ASLR 经常被 memory disclosure （内存泄漏） 攻破

  * 例如, 如果攻击者可以读取指向栈的指针值, 他就可以使用该指针值发现栈在哪里

‍

‍
</code></pre>
<p>[^18]: # 六、恶意代码的机理及其防护</p>
<pre><code>病毒, 蠕虫, 木马, (**侧重：差异, 共性, 如何隐藏**） 

[8-木马.pdf](assets/8-木马-20220618154911-7voq665.pdf)  
[9-病毒.pdf](assets/9-病毒-20220618154910-1q9a44p.pdf)

## 木马

一个典型的特洛伊木马（程序）通常具有以下四个特点：

* 有效性
* 隐蔽性
* 顽固性
* 易植入性

此外，木马还具有以下辅助型特点：

* 自动运行
* 欺骗性
* 自动恢复
* 功能的特殊

‍

### 木马的实现原理与攻击步骤

* 木马实现原理

  * 本质上说，木马大多都是网络**客户/服务（Client/Server）程序**的组合。常由一个攻击者控制的客户端程序和一个运行在被控计算机端的服务端程序组成
  * 当攻击者要利用“木马”进行网络入侵，一般都需完成如下环节：

    * 向目标主机植入木马
    * 启动和隐藏木马
    * 服务器端（目标主机）和客户端建立连接
    * 进行远程控制
* 植入技术

  * 主动植入

    * 本地安装
    * 远程安装

      * 利用系统自身漏洞植入
      * 利用第三方软件漏洞植入
  * 被动植入

    * 网页浏览植入
    * 利用电子邮件植入
    * 利用网络下载植入
    * 利用即时通工具植入
    * 与其它程序捆绑
    * 利用移动存储设备植入
* 自动加载技术

  * 在Windows系统中木马程序的自动加载技术主要有：

    * 修改系统文件
    * 修改系统注册表
    * 添加系统服务
    * 修改文件打开关联属性
    * 修改任务计划
    * 修改组策略
    * 利用系统自动运行的程序
    * 修改启动文件夹
    * 替换系统DLL
* 隐藏技术

  * 隐蔽性是木马程序与其它程序的重要区别
  * 伪隐藏、真隐藏
  * 设置窗口不可见 (从任务栏中隐藏)
  * 把木马程序注册为服务 (从进程列表中隐藏)
  * 欺骗查看进程的函数 (从进程列表中隐藏)
  * 使用可变的高端口 (端口隐藏技术)
  * 使用系统服务端口 (端口隐藏技术)
  * 替换系统驱动或系统DLL (真隐藏技术)
  * 动态嵌入技术 (真隐藏技术)
* 连接技术

  * 反弹窗口的连接技术：更容易通过防火墙
* 监控技术

  木马的远程监控功能概括起来有以下几点：

  * 获取目标机器信息
  * 记录用户事件
  * 远程操作

‍

### 木马的防御技术

* 木马的检测

  * 端口扫描和连接检查
  * 检查系统进程
  * 检查ini文件、注册表和服务
  * 监视网络通讯
* 木马的清除与善后
* 木马的防范

  * 及时修补漏洞，安装补丁
  * 运行实时监控程序
  * 培养风险意识，不使用来历不明的软件
  * 即时发现，即时清除

### 木马的发展趋势

* 跨平台
* 模块化设计
* 无连接木马
* 主动植入
* 木马与病毒的融合

‍

## 病毒

### 计算机病毒的定义

算机病毒一般依附于其他程序或文档，是能够自身复制，并且产生用户不知情或不希望、甚至恶意的操作的非正常程

计算机病毒的特点

* 隐藏性
* 传染性
* 潜伏性
* 破坏性

以上列举的定义指的是**狭义上的病毒**。

但是随着黑客技术的发展，病毒、木马、蠕虫往往交叉在一起相互借鉴技术，因此人们经常说的计算机病毒往往是指**广义上的病毒**，它是一切恶意程序的统称。

‍

计算机病毒的破坏性

* 破坏系统数据
* 破坏目录/文件
* 修改内存
* 干扰系统运行
* 效率降低
* 破坏显示
* 干扰键盘操作
* 制造噪音
* 修改CMOS参数
* 影响打印

计算机病毒引起的异常状况

* 计算机系统运行速度明显降低
* 系统容易死机
* 文件改变
* 磁盘可用空间迅速减少
* 系统参数被修改
* 文件被破坏
* 频繁产生错误信息
* 系统异常频繁重启动
* Office宏病毒提

‍

### 计算机病毒的分类

![Image](https://pic4.zhimg.com/80/v2-951c3b4d92e362d0b2816e5b5335b556.png)

我们针对狭义上的病毒，按照不同的标准对它进行分类。

* 按照计算机病毒攻击的对象或系统平台分类

  * 攻击DOS系统的病毒
  * 攻击WINDOWS系统的病毒
  * 攻击UNIX 系统的病毒
  * 攻击OS/2系统的病毒
  * 其它操作系统上的病毒：如手机病毒
* 按照计算病毒的攻击目标机类型分类：

  * 攻击微型计算机的病毒
  * 攻击小型计算机的病毒
  * 攻击工作站的病毒
* 按照计算机病毒的链接方式分类

  * 源码型病毒
  * 嵌入型病毒
  * 外壳型病毒：包围在主程序的四周
  * 操作系统型病毒
* 按照计算机病毒的破坏情况分类

  * 良性病毒：是不包含有对计算机系统产生直接破坏作用的代码的计算机病毒。
  * 恶性病毒：指在代码中包含有损伤和破坏计算机系统的操作
* 按传播媒介来分类

  * 单机病毒：单机病毒的载体是磁盘或光盘。常见的是通过从软盘传入硬盘，感染系统后，再传染其它软盘。软盘又感染其它系统。
  * 网络病毒：网络为病毒提供了最好的传播途径。网络病毒利用计算机网络的协议或命令以及Email等进行传播，常见的是通过QQ、 BBS、Email、 FTP、 Web等传播

计算机病毒的命名

虽然每个反病毒公司的命名规则都不太一样，但大体都是采用一个统一的命名方法来命名的。一般格式为： &lt;病毒前缀&gt;.&lt;病毒名&gt;.&lt;病毒后缀&gt;

‍

‍

### 计算机病毒的工作机制

* 计算机病毒程序模块划分

  * 感染模块

    1. 寻找一个可执行文件。
    2. 检查该文件中是否有感染标记。
    3. 如果没有感染标记，进行感染，将病毒代码放入宿主程序
  * 触发模块

    * 检查预定触发条件是否满足。
    * 如果满足，返回真值。
    * 如果不满足，返回假值
  * 破坏模块（表现模块）
  * 主控模块

    * 调用感染模块，进行感染。
    * 调用触发模块，接受其返回值。
    * 如果返回真值，执行破坏模块。
    * 如果返回假值，执行后续程序。
* **计算机病毒的生命周期**

  * **感染**
  * **潜伏**
  * **繁殖**
  * **发作**
* 计算机病毒的**传播机制**

  * 病毒入侵宿主程序的基本方式有两种： **替代方式**和**链接方式**。
  * 病毒的宿主程序可分为两类： **操作系统**和**应用程序**。
  * 交叉感染
  * 寄生感染

    * 插入感染
    * 逆插入感染
  * 没有入口点的感染
  * 零长度感染
* 计算机病毒的**触发机制**
* 计算机病毒的**破坏机制**

### 典型的计算机病毒

DOS病毒

Win32 PE病毒

宏病毒

脚本病毒

HTML病毒

蠕虫

### 病毒的隐藏技术

隐藏技术主要有：

* 反跟踪技术
* 避开修改中断向量
* 请求在内存中的合法身份
* 维持宿主程序的外部特性
* 不使用明显的感染标志

### 花指令

‍

### 病毒的多态

多态技术中的密钥和解密代码都变化多端，多态技术将对解密代码进行等价指令替换、寄存器替换、插入垃圾指令或者随机调换指令的前后位置（有些指令的前后位置调换之后不影响代码功能）等变化，以产生功能相同但是代码截然不同的解密代码

多态引擎的组成：

* 指令位置变换模块
* 寄存器变换模块
* 指令扩展模块
* 指令收缩模块
* 等价指令替换模块
* 无用指令随机插入
* 垃圾指令插

‍

## 蠕虫

它与其他的病毒相比，具有传染的主动性

计算机病毒是一段代码，能把自身加到其它程序包括操作系统上。它不能**独立运行**，需要由它的宿主程序运行来激活它”。

Eugene H. Spafford对蠕虫的定义：“**计算机蠕虫可以独立运行**，并能把自身的一个包含所有功能的版本传播到另外的计算机上”

![Image](https://pic4.zhimg.com/80/v2-2510b06e0050ed0528089a6712c63b16.png)

‍![Image](https://pic4.zhimg.com/80/v2-2f7588bb2810d12331b14ece2d21e0f2.png)

‍

‍
</code></pre>
<p>[^19]: ## 病毒</p>
<pre><code>### 计算机病毒的定义

算机病毒一般依附于其他程序或文档，是能够自身复制，并且产生用户不知情或不希望、甚至恶意的操作的非正常程

计算机病毒的特点

* 隐藏性
* 传染性
* 潜伏性
* 破坏性

以上列举的定义指的是**狭义上的病毒**。

但是随着黑客技术的发展，病毒、木马、蠕虫往往交叉在一起相互借鉴技术，因此人们经常说的计算机病毒往往是指**广义上的病毒**，它是一切恶意程序的统称。

‍

计算机病毒的破坏性

* 破坏系统数据
* 破坏目录/文件
* 修改内存
* 干扰系统运行
* 效率降低
* 破坏显示
* 干扰键盘操作
* 制造噪音
* 修改CMOS参数
* 影响打印

计算机病毒引起的异常状况

* 计算机系统运行速度明显降低
* 系统容易死机
* 文件改变
* 磁盘可用空间迅速减少
* 系统参数被修改
* 文件被破坏
* 频繁产生错误信息
* 系统异常频繁重启动
* Office宏病毒提

‍

### 计算机病毒的分类

![Image](https://pic4.zhimg.com/80/v2-951c3b4d92e362d0b2816e5b5335b556.png)

我们针对狭义上的病毒，按照不同的标准对它进行分类。

* 按照计算机病毒攻击的对象或系统平台分类

  * 攻击DOS系统的病毒
  * 攻击WINDOWS系统的病毒
  * 攻击UNIX 系统的病毒
  * 攻击OS/2系统的病毒
  * 其它操作系统上的病毒：如手机病毒
* 按照计算病毒的攻击目标机类型分类：

  * 攻击微型计算机的病毒
  * 攻击小型计算机的病毒
  * 攻击工作站的病毒
* 按照计算机病毒的链接方式分类

  * 源码型病毒
  * 嵌入型病毒
  * 外壳型病毒：包围在主程序的四周
  * 操作系统型病毒
* 按照计算机病毒的破坏情况分类

  * 良性病毒：是不包含有对计算机系统产生直接破坏作用的代码的计算机病毒。
  * 恶性病毒：指在代码中包含有损伤和破坏计算机系统的操作
* 按传播媒介来分类

  * 单机病毒：单机病毒的载体是磁盘或光盘。常见的是通过从软盘传入硬盘，感染系统后，再传染其它软盘。软盘又感染其它系统。
  * 网络病毒：网络为病毒提供了最好的传播途径。网络病毒利用计算机网络的协议或命令以及Email等进行传播，常见的是通过QQ、 BBS、Email、 FTP、 Web等传播

计算机病毒的命名

虽然每个反病毒公司的命名规则都不太一样，但大体都是采用一个统一的命名方法来命名的。一般格式为： &lt;病毒前缀&gt;.&lt;病毒名&gt;.&lt;病毒后缀&gt;

‍

‍

### 计算机病毒的工作机制

* 计算机病毒程序模块划分

  * 感染模块

    1. 寻找一个可执行文件。
    2. 检查该文件中是否有感染标记。
    3. 如果没有感染标记，进行感染，将病毒代码放入宿主程序
  * 触发模块

    * 检查预定触发条件是否满足。
    * 如果满足，返回真值。
    * 如果不满足，返回假值
  * 破坏模块（表现模块）
  * 主控模块

    * 调用感染模块，进行感染。
    * 调用触发模块，接受其返回值。
    * 如果返回真值，执行破坏模块。
    * 如果返回假值，执行后续程序。
* **计算机病毒的生命周期**

  * **感染**
  * **潜伏**
  * **繁殖**
  * **发作**
* 计算机病毒的**传播机制**

  * 病毒入侵宿主程序的基本方式有两种： **替代方式**和**链接方式**。
  * 病毒的宿主程序可分为两类： **操作系统**和**应用程序**。
  * 交叉感染
  * 寄生感染

    * 插入感染
    * 逆插入感染
  * 没有入口点的感染
  * 零长度感染
* 计算机病毒的**触发机制**
* 计算机病毒的**破坏机制**

### 典型的计算机病毒

DOS病毒

Win32 PE病毒

宏病毒

脚本病毒

HTML病毒

蠕虫

### 病毒的隐藏技术

隐藏技术主要有：

* 反跟踪技术
* 避开修改中断向量
* 请求在内存中的合法身份
* 维持宿主程序的外部特性
* 不使用明显的感染标志

### 花指令

‍

### 病毒的多态

多态技术中的密钥和解密代码都变化多端，多态技术将对解密代码进行等价指令替换、寄存器替换、插入垃圾指令或者随机调换指令的前后位置（有些指令的前后位置调换之后不影响代码功能）等变化，以产生功能相同但是代码截然不同的解密代码

多态引擎的组成：

* 指令位置变换模块
* 寄存器变换模块
* 指令扩展模块
* 指令收缩模块
* 等价指令替换模块
* 无用指令随机插入
* 垃圾指令插

‍
</code></pre>
<p>[^20]: ## 木马</p>
<pre><code>一个典型的特洛伊木马（程序）通常具有以下四个特点：

* 有效性
* 隐蔽性
* 顽固性
* 易植入性

此外，木马还具有以下辅助型特点：

* 自动运行
* 欺骗性
* 自动恢复
* 功能的特殊

‍

### 木马的实现原理与攻击步骤

* 木马实现原理

  * 本质上说，木马大多都是网络**客户/服务（Client/Server）程序**的组合。常由一个攻击者控制的客户端程序和一个运行在被控计算机端的服务端程序组成
  * 当攻击者要利用“木马”进行网络入侵，一般都需完成如下环节：

    * 向目标主机植入木马
    * 启动和隐藏木马
    * 服务器端（目标主机）和客户端建立连接
    * 进行远程控制
* 植入技术

  * 主动植入

    * 本地安装
    * 远程安装

      * 利用系统自身漏洞植入
      * 利用第三方软件漏洞植入
  * 被动植入

    * 网页浏览植入
    * 利用电子邮件植入
    * 利用网络下载植入
    * 利用即时通工具植入
    * 与其它程序捆绑
    * 利用移动存储设备植入
* 自动加载技术

  * 在Windows系统中木马程序的自动加载技术主要有：

    * 修改系统文件
    * 修改系统注册表
    * 添加系统服务
    * 修改文件打开关联属性
    * 修改任务计划
    * 修改组策略
    * 利用系统自动运行的程序
    * 修改启动文件夹
    * 替换系统DLL
* 隐藏技术

  * 隐蔽性是木马程序与其它程序的重要区别
  * 伪隐藏、真隐藏
  * 设置窗口不可见 (从任务栏中隐藏)
  * 把木马程序注册为服务 (从进程列表中隐藏)
  * 欺骗查看进程的函数 (从进程列表中隐藏)
  * 使用可变的高端口 (端口隐藏技术)
  * 使用系统服务端口 (端口隐藏技术)
  * 替换系统驱动或系统DLL (真隐藏技术)
  * 动态嵌入技术 (真隐藏技术)
* 连接技术

  * 反弹窗口的连接技术：更容易通过防火墙
* 监控技术

  木马的远程监控功能概括起来有以下几点：

  * 获取目标机器信息
  * 记录用户事件
  * 远程操作

‍

### 木马的防御技术

* 木马的检测

  * 端口扫描和连接检查
  * 检查系统进程
  * 检查ini文件、注册表和服务
  * 监视网络通讯
* 木马的清除与善后
* 木马的防范

  * 及时修补漏洞，安装补丁
  * 运行实时监控程序
  * 培养风险意识，不使用来历不明的软件
  * 即时发现，即时清除

### 木马的发展趋势

* 跨平台
* 模块化设计
* 无连接木马
* 主动植入
* 木马与病毒的融合

‍
</code></pre>
<p>[^21]: ## 蠕虫</p>
<pre><code>它与其他的病毒相比，具有传染的主动性

计算机病毒是一段代码，能把自身加到其它程序包括操作系统上。它不能**独立运行**，需要由它的宿主程序运行来激活它”。

Eugene H. Spafford对蠕虫的定义：“**计算机蠕虫可以独立运行**，并能把自身的一个包含所有功能的版本传播到另外的计算机上”

![Image](https://pic4.zhimg.com/80/v2-2510b06e0050ed0528089a6712c63b16.png)

![Image](https://pic4.zhimg.com/80/v2-2f7588bb2810d12331b14ece2d21e0f2.png)

‍

‍
</code></pre>
<p>[^22]: ### 模糊测试</p>
<pre><code>模糊测试:在很多随机的、不正常的输入上运行程序，找出程序对这些输入进行响应时的错误行为(如崩溃、挂起)

#### 黑盒 fuzzing 
</code></pre>
<p>​<br>​    #### 基于突变（mutation）的 fuzzing<br>​<br>​    ‍<br>​<br>​    #### 基于生成的 Fuzzing<br>​<br>    ‍</p>
<pre><code>#### 基于覆盖（Coverage）的 Fuzzing
</code></pre>
<p>​<br>​    ##### AFL：<br>​<br>​    #### 白盒 Fuzzing</p>
<p>[^24]: ## 代码混淆</p>
<pre><code>目标：阻止对软件实施非授权的逆向分析

核心方法： 语义保留的程序变换

‍

### 代码混淆的可能性

借鉴密码学算法的安全模型。目标：可证明安全性

![Image](https://pic4.zhimg.com/80/v2-85b567782e25041b89fe82f71ceae89c.png)

![Image](https://pic4.zhimg.com/80/v2-b8efb418f3bc21b84a6633e32dab71bd.png)

然而，“虚拟黑盒”式的混淆器真的可以实现吗？

研究结论： 不可能

核心因素： 程序执行与Oracle访问有着本质区别

* 程序是对函数的简明描述
* Oracle访问只给出函数的输入-输出映射关系
* 函数的功能往往无法通过Oracle访问的方式予以精确学习

‍

代码混淆的实际能力

* 做不到： 让程序的执行逻辑变得不可知
* 做得到： 使程序的执行逻辑变得难以理

‍

### 代码混淆的方法

#### 不透明谓词（ opaque predicate）

较强的构造方法：基于3SAT问题 [通过3SAT证明支配集是NPC问题 | 骑士的个人主页 (samjjx.github.io)](https://samjjx.github.io/2019/03/14/3sat2ds/)

* [ ] 问题：证明显示不透明谓词在计算上是不安全的

‍

#### 条件分支混淆

![image.png](assets/image-20220618162047-tunkqes.png)

方法：

* 单向函数

* 利用分析技术弱点

* 利用神经网络
</code></pre>
<p>[^25]: ## 软件防篡改</p>
<pre><code>目标：

* 使得软件的内部逻辑无法被篡改
* 当篡改发生时，完成自我诊断/修复

意义： 阻止对软件的破解

方法：

* 内省自检（introspection）

* Oblivious Hashing *未察觉的哈希*
</code></pre>
<p>​<br>​    新场景：对抗 app 重打包<br>​<br>​    ‍</p>
<p>[^26]: ## 软件混淆</p>
<pre><code>### 软件胎记

胎记”的实际含义

* 一类对象的本质特征
* 与生俱来
* 独一无二

‍

软件胎记的广义安全价值

* 反代码剽窃（未经授权使用共享库，或违反协议使用开源代码）
* 检测恶意代码（特别是经过各种伪装保护的）
* 检测移动app的重包装

构造形式分类

* 静态/动态（取决于胎记所依赖的特征类型）

‍

静态构造举例：基于JAVA的栈行为模式

动态构造1：基于执行路

动态构造2：基于程序内的系统调用

&gt; 不懂呀
&gt;

‍

### 软件水印

目标：在软件中嵌入用于标识其版权归属的秘密信息

软件水印的应用形式

* 反盗版 – 通过声明版权
* 反盗版 – 通过追溯盗版母盘的来源

软件水印的形式分类

* 静态/动态（取决于水印的构造方式）

**静态构造举例：基本块重排序**

**静态构造举例：寄存器占用重分配**

**传统动态构造1：基于动态生成的图对象**

**传统动态构造2：基于执行路径上的分支行为**

**传统动态构造3：基于多线程的同步**

‍

传统动态构造的问题1：

* 与主程序的关联性很弱
* 往往具有显著的模式/特征
* 很难予以隐藏或伪装

一个特别的设计：基于抽象解释的水印

* 在正常维度上，水印组件服务于载体软件的原本功能
* 在预设的秘密维度上，水印组件展示出隐藏的信息
</code></pre>
<p>​<br>​    <strong>改进动态构造 1：利用返回导向编程</strong><br>​<br>​    <strong>改进动态构造 2：利用代码混淆</strong></p>
<p>​<br>​    <strong>传统动态构造的问题 2：</strong></p>
<p>​<br>​    <strong>改进动态构造 3：利用神经网络</strong></p>
<p>​<br>​    软件水印仍然存在的不足之处<br>​<br>​    * 没有在真正意义上实现隐蔽性<br>​    * 缺乏有效的定性&#x2F;定量评估标准（特别是隐蔽性这一安全度量）<br>​    * 数据嵌入率很差<br>​    * 没有解决工业化、自动化实施的问题<br>​<br>​    ‍<br>​<br>    ‍</p>
<p>[^27]: # 九、Web 安全</p>
<pre><code> [10-Web-sec.pdf](assets/10-Web-sec-20220618155749-pbm5v2t.pdf)

[10-web-sec-companion-pu.pptx](assets/10-web-sec-companion-pu-20220622153058-vmf68up.pptx)

## **输入验证**: SQL**注入攻击**

*看PPT吧*

脆弱性: 任意编程语言实现的连接到SQL数据库的应用程序都可能存在

‍

## **输入验证**: 跨站脚本 (XSS, Cross‐Site Scripting)

*看PPT吧*

脆弱性：用户输入, 可能包含可执行内容 (JavaScript, VBscript, ActiveX, ..)被弹回到一个web页面

‍
</code></pre>
<p>[^28]: ## <strong>输入验证</strong>: SQL<strong>注入攻击</strong></p>
<pre><code>*看 PPT 吧*

脆弱性：任意编程语言实现的连接到 SQL 数据库的应用程序都可能存在

‍
</code></pre>
<p>[^29]: ## <strong>输入验证</strong>: 跨站脚本 (XSS, Cross‐Site Scripting)</p>
<pre><code>*看 PPT 吧*

脆弱性：用户输入，可能包含可执行内容 (JavaScript, VBscript, ActiveX, ..) 被弹回到一个 web 页面

‍
</code></pre>
<p>[^30]: #### 代码重用攻击：Return to libc</p>
<pre><code>危险库函数如 `system()`

攻击者构造合适的参数(在栈上, 返回指令指针的上方)

* 在x64架构上，还需要更多的工作：设置参数传递寄存器的值

函数返回，库函数得到执行

* 例如：`execve(“/bin/sh”)`

甚至可以链接两个库函数调用
</code></pre>
<p>​<br>​    &#x3D;&#x3D;<strong>具体地</strong>&#x3D;&#x3D;<br>​<br>​    * 攻击者用一个溢出填充 buffer:<br>​<br>​      * 更改栈上保存的 ebp 为一个合适地址<br>​      * 更改返回指令指针为一个欲执行的库函数的地址<br>​      * 写一个占位符值 (库函数会认为其是返回地址，如果想利用它调用第二个库函数，应写入第二个库函数的地址)<br>​      * 写一个或多个要传递给此库函数的参数<br>​    * 当被攻击的函数返回时，恢复 (更改过的)ebp, 然后 pop 更改后的返回地址到 eip, 从而开始执行库函数代码<br>​    * 因为库函数相信它已被调用，故会将栈顶当前值 (占位符) 作为它自己栈帧的返回指令指针，之上是参数<br>​    * 最终会在占位符位置的下方创建起一个新的栈帧 (对应于库函数的执行)<br>​    * 根据库函数参数类型以及库函数对参数的解释方式，攻击者可能需要准确地知道参数地址以做溢出写<br>​<br>    ‍</p>
<p>[^31]: ### 木马的实现原理与攻击步骤</p>
<pre><code>* 木马实现原理

  * 本质上说，木马大多都是网络**客户/服务（Client/Server）程序**的组合。常由一个攻击者控制的客户端程序和一个运行在被控计算机端的服务端程序组成
  * 当攻击者要利用“木马”进行网络入侵，一般都需完成如下环节：

    * 向目标主机植入木马
    * 启动和隐藏木马
    * 服务器端（目标主机）和客户端建立连接
    * 进行远程控制
* 植入技术

  * 主动植入

    * 本地安装
    * 远程安装

      * 利用系统自身漏洞植入
      * 利用第三方软件漏洞植入
  * 被动植入

    * 网页浏览植入
    * 利用电子邮件植入
    * 利用网络下载植入
    * 利用即时通工具植入
    * 与其它程序捆绑
    * 利用移动存储设备植入
* 自动加载技术

  * 在 Windows 系统中木马程序的自动加载技术主要有：

    * 修改系统文件
    * 修改系统注册表
    * 添加系统服务
    * 修改文件打开关联属性
    * 修改任务计划
    * 修改组策略
    * 利用系统自动运行的程序
    * 修改启动文件夹
    * 替换系统 DLL
* 隐藏技术

  * 隐蔽性是木马程序与其它程序的重要区别
  * 伪隐藏、真隐藏
  * 设置窗口不可见 (从任务栏中隐藏)
  * 把木马程序注册为服务 (从进程列表中隐藏)
  * 欺骗查看进程的函数 (从进程列表中隐藏)
  * 使用可变的高端口 (端口隐藏技术)
  * 使用系统服务端口 (端口隐藏技术)
  * 替换系统驱动或系统 DLL (真隐藏技术)
  * 动态嵌入技术 (真隐藏技术)
* 连接技术

  * 反弹窗口的连接技术：更容易通过防火墙
* 监控技术

  木马的远程监控功能概括起来有以下几点：

  * 获取目标机器信息
  * 记录用户事件
  * 远程操作

‍
</code></pre>
<p>[^32]: ### 计算机病毒的分类</p>
<pre><code>![Image](https://pic4.zhimg.com/80/v2-951c3b4d92e362d0b2816e5b5335b556.png)

我们针对狭义上的病毒，按照不同的标准对它进行分类。

* 按照计算机病毒攻击的对象或系统平台分类

  * 攻击DOS系统的病毒
  * 攻击WINDOWS系统的病毒
  * 攻击UNIX 系统的病毒
  * 攻击OS/2系统的病毒
  * 其它操作系统上的病毒：如手机病毒
* 按照计算病毒的攻击目标机类型分类：

  * 攻击微型计算机的病毒
  * 攻击小型计算机的病毒
  * 攻击工作站的病毒
* 按照计算机病毒的链接方式分类

  * 源码型病毒
  * 嵌入型病毒
  * 外壳型病毒：包围在主程序的四周
  * 操作系统型病毒
* 按照计算机病毒的破坏情况分类

  * 良性病毒：是不包含有对计算机系统产生直接破坏作用的代码的计算机病毒。
  * 恶性病毒：指在代码中包含有损伤和破坏计算机系统的操作
* 按传播媒介来分类

  * 单机病毒：单机病毒的载体是磁盘或光盘。常见的是通过从软盘传入硬盘，感染系统后，再传染其它软盘。软盘又感染其它系统。
  * 网络病毒：网络为病毒提供了最好的传播途径。网络病毒利用计算机网络的协议或命令以及Email等进行传播，常见的是通过QQ、 BBS、Email、 FTP、 Web等传播

计算机病毒的命名

虽然每个反病毒公司的命名规则都不太一样，但大体都是采用一个统一的命名方法来命名的。一般格式为： &lt;病毒前缀&gt;.&lt;病毒名&gt;.&lt;病毒后缀&gt;

‍

‍
</code></pre>
<p>[^33]: ### 病毒的隐藏技术</p>
<pre><code>隐藏技术主要有：

* 反跟踪技术
* 避开修改中断向量
* 请求在内存中的合法身份
* 维持宿主程序的外部特性
* 不使用明显的感染标志
</code></pre>
<p>[^34]: ### 病毒的多态</p>
<pre><code>多态技术中的密钥和解密代码都变化多端，多态技术将对解密代码进行等价指令替换、寄存器替换、插入垃圾指令或者随机调换指令的前后位置（有些指令的前后位置调换之后不影响代码功能）等变化，以产生功能相同但是代码截然不同的解密代码

多态引擎的组成：

* 指令位置变换模块
* 寄存器变换模块
* 指令扩展模块
* 指令收缩模块
* 等价指令替换模块
* 无用指令随机插入
* 垃圾指令插

‍
</code></pre>
<p>[^35]: ## Man-At-The-End 攻击 (MATE)</p>
<pre><code>攻击者： 位于终端，对终端计算资源有最高控制权限

攻击对象：安装在受控终端上的软件程序

攻击目的： 获悉、篡改软件的内部逻辑

![Image](https://pic4.zhimg.com/80/v2-c29b125e1969dd2db8345c1ea1653606.png)

‍
</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      <div style="display: inline-block;">
        <img src="/images/dogecoin.png" alt="Framist dogecoin">
        <p>dogecoin</p>
      </div>
      <div style="display: inline-block;">
        <img src="/images/afdian.jpg" alt="Framist afdian">
        <p>afdian</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Framist
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://framist.github.io/post/64689.html" title="【软件与系统安全】笔记与期末复习">https://framist.github.io/post/64689.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag"># 二进制</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/52515.html" rel="prev" title="【MATLAB】多目标优化算法 NSGA-II(gamultiobj) 的使用精解">
      <i class="fa fa-chevron-left"></i> 【MATLAB】多目标优化算法 NSGA-II(gamultiobj) 的使用精解
    </a></div>
      <div class="post-nav-item">
    <a href="/post/25371.html" rel="next" title="看保研情侣事件">
      看保研情侣事件 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%90%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E3%80%91"><span class="nav-number">1.</span> <span class="nav-text">【软件与系统安全】</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%AF%BE%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">关于课程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">笔记列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99"><span class="nav-number">1.3.</span> <span class="nav-text">课程资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9"><span class="nav-number">1.4.</span> <span class="nav-text">期末复习重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%AE%89%E7%8F%AD%E9%87%8D%E7%82%B9"><span class="nav-number">1.4.1.</span> <span class="nav-text">信安班重点</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Framist</p>
  <div class="site-description" itemprop="description">框架主义者的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/framist" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;framist" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:framist@163.com" title="E-Mail → mailto:framist@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_47102975" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_47102975" rel="noopener" target="_blank"><i class="fas fa-angle-right fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/kuang-jia-zhu-yi-zhe" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;kuang-jia-zhu-yi-zhe" rel="noopener" target="_blank"><i class="fas fa-angle-right fa-fw"></i>知乎</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://framist.top/" title="http:&#x2F;&#x2F;framist.top&#x2F;" rel="noopener" target="_blank">个人主页</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://craft.framist.top/" title="https:&#x2F;&#x2F;craft.framist.top&#x2F;" rel="noopener" target="_blank">框架科工</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://framist.github.io/2020/10/11/%E6%88%91%E8%BA%AB%E8%BE%B9%E7%9A%84CS%E5%A4%A7%E4%BD%AC%E4%BB%AC/" title="https:&#x2F;&#x2F;framist.github.io&#x2F;2020&#x2F;10&#x2F;11&#x2F;%E6%88%91%E8%BA%AB%E8%BE%B9%E7%9A%84CS%E5%A4%A7%E4%BD%AC%E4%BB%AC&#x2F;">我身边的大佬们</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yuexiavqiufeng.github.io/" title="https:&#x2F;&#x2F;yuexiavqiufeng.github.io&#x2F;" rel="noopener" target="_blank">yuexiavqiufeng</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙 ICP 备 2022002862 号 -1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-at"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Framist</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script>
    let body = document.getElementsByTagName('body')[0];
    body.addEventListener('click', (e) => {
        let contentArr = ['欧拉~','ˋ( ° ▽、° ) ','RGB!','_(:з」∠)_','哼','?','¿框架?','QAQ',':3','<3','疯掉了',
                            'whoami',
                            'whoareU',
                            'NULL',
                            'None',
                            ' ',
                            '代价是什么呢？',
                            '...',
                            'Big Brother is Watching You',
                            '喵~', '嗷~', '呜~', '哞~', '咩~', '咕~', '嘎~', '嘤~',
                            '你看到了。',
                            '¿爱情障眼法?','¿物种认同障碍?',
                            '微润欧美，小润终南山，中润润与市，大润中南海',
                            'init param:<br/>1LTKvNaux7CjrNHJ09C0y87Eo7/Rrbu3zfm4tKOsus<br/>7Ksbb41rmjv9a5zqrWucv51rmjrLTLzsTT1rrOtOajvw==',
                            '这里没有时间的意义',
                            '嘿嘿嘿，好想被随机异或哦，<br/>嘿嘿嘿，嘿嘿嘿，异或我的异或',
                            '记忆赋予时间的意义，而不是时间赋予记忆的意义',
                            '放弃 P ∨ ¬P 吧！',
                            '抽象是普适性的代价 —— 3b1b',
                            '得易见平凡，仿照上例显然',
                            '留作习题答案略，读者自证不难',
                            '反之亦然同理，推论自然成立',
                            '略去过程 Q . E . D ，由上可知证毕'];
        let randomNum = function (n) {
            return Math.floor(Math.random() * n)
        }
        let span = document.createElement('span');
        span.innerHTML = `${contentArr[randomNum(contentArr.length)]}`;
        span.style.color = `rgb(${randomNum(256)},${randomNum(256)},${randomNum(256)})`;
        span.style.position = 'absolute';
        span.style.top = `${e.pageY - 25 - randomNum(50)}px`;
        span.style.left = `${e.pageX - randomNum(50)}px`;
        span.style.transition = 'all 1.5s ease';
        span.style.zIndex = 20000;
        span.style.fontSize = `${randomNum(8) + 10}px`;
        body.appendChild(span)
        setTimeout(()=>{
            span.style.top = span.offsetTop - 25 + 'px';
            span.style.opacity = 0;
            setTimeout(()=>{span.remove()},1000)
        },700)
    })
</script>


<div style="width: 100px; height: 100px; margin: 0 auto;">
<script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=gRWtX21uVt_tIdj_T64nMvo4FK1UrTWME23CVLOzNCg"></script>
</div>
<!--
<script type="text/javascript" 
color="255,255,255" 
pointColor='64,184,209' 
opacity='1' 
zIndex="-1" 
count="233" 
src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js">
</script>
-->


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '267a9d4a89b9b72b2229',
      clientSecret: '2dba1f14d21da707ed6c4497fecc05d6178b4fa3',
      repo        : 'blog-comment',
      owner       : 'framist',
      admin       : ['framist'],
      id          : '58e4f1f21cea767900c568a8a75d4820',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
