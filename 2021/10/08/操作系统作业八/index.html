<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"framist.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Operating System Concepts Exercises 8Main Memory   操作系统作业8  网上学习理解“代码可重入” 8.1，8.4，8.5，8.6，8.7 8.9， 8.12，8.13，8.14，8.15，8.18，8.19，8.20，8.21，8.23，8.28，8.29">
<meta property="og:type" content="article">
<meta property="og:title" content="【操作系统概念-作业8】Main Memory">
<meta property="og:url" content="https://framist.github.io/2021/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E5%85%AB/index.html">
<meta property="og:site_name" content="Framist&#39;s Little House">
<meta property="og:description" content="Operating System Concepts Exercises 8Main Memory   操作系统作业8  网上学习理解“代码可重入” 8.1，8.4，8.5，8.6，8.7 8.9， 8.12，8.13，8.14，8.15，8.18，8.19，8.20，8.21，8.23，8.28，8.29">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-08T11:51:44.057Z">
<meta property="article:modified_time" content="2021-10-08T11:55:22.122Z">
<meta property="article:author" content="Framist">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://framist.github.io/2021/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E5%85%AB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【操作系统概念-作业8】Main Memory | Framist's Little House</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Framist's Little House</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">◇ 自顶而下 - 面向未来 ◇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://framist.github.io/2021/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E5%85%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Framist">
      <meta itemprop="description" content="框架主义者的小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Framist's Little House">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【操作系统概念-作业8】Main Memory
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-08 19:51:44 / 修改时间：19:55:22" itemprop="dateCreated datePublished" datetime="2021-10-08T19:51:44+08:00">2021-10-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E4%B8%9A%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">课业学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E4%B8%9A%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Operating-System-Concepts-Exercises-8"><a href="#Operating-System-Concepts-Exercises-8" class="headerlink" title="Operating System Concepts Exercises 8"></a><em>Operating System Concepts</em> Exercises 8</h1><center>Main Memory</center>


<p>操作系统作业8</p>
<ul>
<li>网上学习理解“代码可重入”</li>
<li>8.1，8.4，8.5，8.6，8.7</li>
<li>8.9， 8.12，8.13，8.14，8.15，8.18，8.19，8.20，8.21，8.23，8.28，8.29</li>
</ul>
<a id="more"></a>

<p><em>每题最后一个引用块是老师提供的参考答案</em></p>
<h2 id="网上学习理解“代码可重入”"><a href="#网上学习理解“代码可重入”" class="headerlink" title="网上学习理解“代码可重入”"></a>网上学习理解“代码可重入”</h2><blockquote>
<p>若一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">子程序</a>可以“在任意时刻被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%AD">中断</a>然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为<strong>可重入</strong>（reentrant或re-entrant）的。即当该子程序正在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%B7%E8%A1%8C%E6%9C%9F">运行时</a>，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">线程安全</a>不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</p>
<p>可重入概念是在单线程操作系统的时代提出的。一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">子程序</a>的重入，可能由于自身原因，如执行了jmp或者call，类似于子程序的递归调用；或者由于操作系统的中断响应。UNIX系统的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">signal</a>的处理，即子程序被中断处理程序或者signal处理程序调用。所以，可重入也可称作“异步信号安全”。这里的异步是指信号中断可发生在任意时刻。 重入的子程序，按照后进先出线性序依次执行。</p>
<p>若一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>是可重入的，则该函数应当满足下述条件：</p>
<ul>
<li>不能含有静态（全局）非常量数据。</li>
<li>不能返回静态（全局）非常量数据的地址。</li>
<li>只能处理由调用者提供的数据。</li>
<li>不能依赖于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%BC%8F">单实例模式</a>资源的锁。</li>
<li>调用(call)的函数也必需是可重入的。</li>
</ul>
<p>上述条件就是要求可重入函数使用的所有变量都保存在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A">呼叫堆叠</a>的当前<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%87%BD%E6%95%B0%E6%A0%88&action=edit&redlink=1">函数栈</a>（frame）上，因此同一执行线程重入执行该函数时加载了新的函数帧，与前一次执行该函数时使用的函数帧不冲突、不互相覆盖，从而保证了可重入执行安全。</p>
<p>多“用户/对象/进程<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">优先级</a>”以及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%BF%9B%E7%A8%8B">多进程</a>（Multiple processes），一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的（类似<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E7%A8%8B">编程</a>中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9C%E6%85%8B&action=edit&redlink=1">静态</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8">全域</a>）资源。</p>
<p>可重入性是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">函数编程语言</a>的关键特性之一。</p>
</blockquote>
<p>[1]</p>
<h2 id="Practice-Exercises"><a href="#Practice-Exercises" class="headerlink" title="Practice Exercises"></a>Practice Exercises</h2><p>8.1，8.4，8.5，8.6，8.7</p>
<h3 id="8-1-Name-two-differences-between-logical-and-physical-addresses"><a href="#8-1-Name-two-differences-between-logical-and-physical-addresses" class="headerlink" title="8.1 Name two differences between logical and physical addresses."></a>8.1 Name two differences between logical and physical addresses.</h3><p>说出逻辑地址和物理地址的两个区别。</p>
<p><strong>答：</strong></p>
<blockquote>
<p>An address generated by the CPU is commonly referred to as a logical address, whereas an address seen by the memory unit—that is, the one loaded into the memory-address register of the memory—is commonly referred to as a physical address.</p>
<p>——教材P355</p>
</blockquote>
<p>物理地址是真实的地址，而逻辑地址不是。</p>
<p>逻辑地址范围为0 ~ max，物理地址范围为R + 0 ~ R + max。</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>The basic difference between Logical and physical address is that Logical address is generated by CPU in perspective of a running program. On the other hand, the physical address is a location that exists in the memory unit, and can be accessed physically.</p>
<p>逻辑地址和物理地址的基本区别是，逻辑地址是由CPU从运行程序的角度产生的。另一方面，物理地址是存在于内存单元中的一个位置，可以被物理访问。</p>
<p>The set of all logical addresses generated by CPU for a program is called Logical Address Space. However, the set of all physical address mapped to corresponding logical addresses is referred as Physical Address Space.</p>
<p>由CPU为一个程序生成的所有逻辑地址的集合被称为逻辑地址空间。然而，所有物理地址映射到相应的逻辑地址的集合被称为物理地址空间。</p>
<p>Identical logical address and physical address are generated by Compile-time and Load time address binding methods.</p>
<p>相同的逻辑地址和物理地址是由编译时和加载时的地址绑定方法产生的。</p>
<p>The logical and physical address generated by run-time address binding method (Memory Management Unit) differs from each other.</p>
<p>由运行时地址绑定方法（内存管理单元）生成的逻辑地址和物理地址彼此不同。</p>
</blockquote>
<h3 id="8-4-Consider-a-logical-address-space-of-64-pages-of-1-024-words-each-mapped-onto-a-physical-memory-of-32-frames"><a href="#8-4-Consider-a-logical-address-space-of-64-pages-of-1-024-words-each-mapped-onto-a-physical-memory-of-32-frames" class="headerlink" title="8.4 Consider a logical address space of 64 pages of 1,024 words each, mapped onto a physical memory of 32 frames."></a>8.4 Consider a logical address space of 64 pages of 1,024 words each, mapped onto a physical memory of 32 frames.</h3><p>考虑一个由64个页面组成的逻辑地址空间，每个页面有1,024个字，映射到32个帧的物理存储器上。</p>
<h4 id="a-How-many-bits-are-there-in-the-logical-address"><a href="#a-How-many-bits-are-there-in-the-logical-address" class="headerlink" title="a. How many bits are there in the logical address?"></a>a. How many bits are there in the logical address?</h4><p><strong>答：</strong> <del>64*1024words</del></p>
<h4 id="b-How-many-bits-are-there-in-the-physical-address"><a href="#b-How-many-bits-are-there-in-the-physical-address" class="headerlink" title="b. How many bits are there in the physical address?"></a>b. How many bits are there in the physical address?</h4><p><strong>答：</strong> <del>32*1024words</del></p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>a. Logical address: 16 bits</p>
<p>b. Physical address: 15 bits</p>
</blockquote>
<h3 id="8-5-What-is-the-effect-of-allowing-two-entries-in-a-page-table-to-point-to-the-same-page-frame-in-memory-Explain-how-this-effect-could-be-used-to-decrease-the-amount-of-time-needed-to-copy-a-large-amount-of-memory-from-one-place-to-another-What-effect-would-updating-some-byte-on-the-one-page-have-on-the-other-page"><a href="#8-5-What-is-the-effect-of-allowing-two-entries-in-a-page-table-to-point-to-the-same-page-frame-in-memory-Explain-how-this-effect-could-be-used-to-decrease-the-amount-of-time-needed-to-copy-a-large-amount-of-memory-from-one-place-to-another-What-effect-would-updating-some-byte-on-the-one-page-have-on-the-other-page" class="headerlink" title="8.5 What is the effect of allowing two entries in a page table to point to the same page frame in memory? Explain how this effect could be used to decrease the amount of time needed to copy a large amount of memory from one place to another. What effect would updating some byte on the one page have on the other page?"></a>8.5 What is the effect of allowing two entries in a page table to point to the same page frame in memory? Explain how this effect could be used to decrease the amount of time needed to copy a large amount of memory from one place to another. What effect would updating some byte on the one page have on the other page?</h3><p>允许页表中的两个条目指向内存中的同一个页框有什么效果？</p>
<p><strong>答：</strong> 节省内存空间</p>
<p>解释一下如何利用这种效果来减少将大量内存从一个地方复制到另一个地方所需的时间。</p>
<p><strong>答：</strong> 这样子就不需要花费时间复制内存了</p>
<p>更新一个页面上的某些字节对另一个页面有什么影响？</p>
<p><strong>答：</strong> 会产生同样的变化</p>
<blockquote>
<p><strong>Answer</strong>:</p>
<p>By allowing two entries in a page table to point to the same page frame in memory, users can share code and data. If the code is reentrant, much memory space can be saved through the shared use of large programs such as text editors, compilers, and database systems. “Copying” large amounts of memory could be effected by having different page tables point to the same memory location.</p>
<p>However, sharing of non-reentrant code or data means that any user having access to the code can modify it and these modifications would be reflected in the other user’s “copy”. So “copy-on-write” should be used.</p>
<p>通过允许页表中的两个条目指向内存中的同一个页框，用户可以共享代码和数据。如果代码是可重入的，通过共享使用大型程序，如文本编辑器、编译器和数据库系统，可以节省很多内存空间。”复制 “大量的内存可以通过让不同的页表指向同一个内存位置来实现。</p>
<p>然而，共享非重复性的代码或数据意味着任何能够访问该代码的用户都可以修改它，这些修改将反映在其他用户的 “副本 “中。所以应该使用 “写时拷贝”。</p>
</blockquote>
<h3 id="8-6-Describe-a-mechanism-by-which-one-segment-could-belong-to-the-address-space-of-two-different-processes"><a href="#8-6-Describe-a-mechanism-by-which-one-segment-could-belong-to-the-address-space-of-two-different-processes" class="headerlink" title="8.6  Describe a mechanism by which one segment could belong to the address space of two different processes."></a>8.6  Describe a mechanism by which one segment could belong to the address space of two different processes.</h3><p>描述一种机制，通过这种机制，一个段可以属于两个不同进程的地址空间。</p>
<p><strong>答：</strong> 共享页</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>Since segment tables are a collection of base–limit registers, segments can be shared when entries in the segment table of two different processes point to the same physical location. </p>
<p>The two segment tables must have identical base pointers, and the shared segment number must be the same in the two processes.</p>
<p>由于段表是基限寄存器的集合，当两个不同进程的段表中的条目指向同一个物理位置时，段可以被共享。</p>
<p>这两个段表必须有相同的基数指针，而且两个进程中的共享段号必须相同。</p>
</blockquote>
<h3 id="8-7-Sharing-segments-among-processes-without-requiring-that-they-have-the-same-segment-number-is-possible-in-a-dynamically-linked-segmentation-system"><a href="#8-7-Sharing-segments-among-processes-without-requiring-that-they-have-the-same-segment-number-is-possible-in-a-dynamically-linked-segmentation-system" class="headerlink" title="8.7 Sharing segments among processes without requiring that they have the same segment number is possible in a dynamically linked segmentation system."></a>8.7 Sharing segments among processes without requiring that they have the same segment number is possible in a dynamically linked segmentation system.</h3><p>在动态链接的分段系统中，进程之间共享分段而不要求它们有相同的分段编号是可能的。</p>
<h4 id="a-Define-a-system-that-allows-static-linking-and-sharing-of-segments-without-requiring-that-the-segment-numbers-be-the-same"><a href="#a-Define-a-system-that-allows-static-linking-and-sharing-of-segments-without-requiring-that-the-segment-numbers-be-the-same" class="headerlink" title="a. Define a system that allows static linking and sharing of segments without requiring that the segment numbers be the same."></a>a. Define a system that allows static linking and sharing of segments without requiring that the segment numbers be the same.</h4><p>定义一个系统，允许静态链接和共享段，而不要求段号相同。</p>
<p><strong>答：</strong> 可以通过共享页来实现，不同的段指向相同的页</p>
<h4 id="b-Describe-a-paging-scheme-that-allows-pages-to-be-shared-without-requiring-that-the-page-numbers-be-the-same"><a href="#b-Describe-a-paging-scheme-that-allows-pages-to-be-shared-without-requiring-that-the-page-numbers-be-the-same" class="headerlink" title="b. Describe a paging scheme that allows pages to be shared without requiring that the page numbers be the same."></a>b. Describe a paging scheme that allows pages to be shared without requiring that the page numbers be the same.</h4><p>描述一种允许共享页面而不要求页码相同的分页方案。</p>
<p><strong>答：</strong> 不同页映射到相同的帧</p>
<blockquote>
<p><strong>Answer:</strong> </p>
<p>Both of these problems reduce to a program being able to reference both its own code and its data without knowing the segment or page number associated with the address. MULTICS solved this problem by associating four registers with each process. One register had the address of the current program segment, another had a base address for the stack, another had a base address for the global data, and so on. The idea isthat all references have to be indirect through a register that maps to the current segment or page number. By changing these registers, the same code can execute for different processes without the same page or segment numbers.</p>
<p>这两个问题都简化为程序能够同时引用自己的代码和数据而不知道与地址相关的段或页号。MULTICS通过将四个寄存器与每个进程联系起来解决了这个问题。一个寄存器是当前程序段的地址，另一个是堆栈的基址，另一个是全局数据的基址，以此类推。这个想法是，所有的引用都必须通过映射到当前程序段或页号的寄存器间接进行。通过改变这些寄存器，相同的代码可以在没有相同页或段号的情况下为不同的进程执行。</p>
</blockquote>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><p>8.9， 8.12，8.13，8.14，8.15，8.18，8.19，8.20，8.21，8.23，8.28，8.29</p>
<h3 id="8-9-Explain-the-difference-between-internal-and-external-fragmentation"><a href="#8-9-Explain-the-difference-between-internal-and-external-fragmentation" class="headerlink" title="8.9 Explain the difference between internal and external fragmentation."></a>8.9 Explain the difference between internal and external fragmentation.</h3><p>解释内部和外部碎片的区别。</p>
<p><strong>答：</strong> </p>
<p>内部碎片是填不满页表产生的碎片，目前没有很好地办法解决；外部碎片是内存分配中产生的碎片，目前可以用分页方案完美解决。</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>Internal fragmentation occurs when fixed sized memory blocks are allocated to the processes. The memory assigned to the process is slightly larger than the memory requested by the process. <strong>It is the area occupied by a process but cannot be used by the process</strong>. This space is unusable by the system until the process release the space.</p>
<p>External fragmentation occurs when variable size memory space are allocated to the processes dynamically. <strong>It exists when total free memory (holes) is enough for the new process but it’s not contiguous and can’t satisfy the request</strong>. Storage is fragmented into small holes.</p>
<p>当固定大小的内存块被分配给进程时，就会发生内部碎片化。分配给进程的内存比进程要求的内存略大。<strong>它是被进程占用但不能被进程使用的区域</strong>。这个空间在进程释放空间之前，系统是无法使用的。</p>
<p>当可变大小的内存空间被动态地分配给进程时，就会出现外部碎片。<strong>它存在于总的自由内存（孔）足够新进程使用，但它不是连续的，不能满足要求</strong>。存储被分割成小孔。</p>
</blockquote>
<h3 id="8-12-Most-systems-allow-a-program-to-allocate-more-memory-to-its-address-space-during-execution-Allocation-of-data-in-the-heap-segments-of-programs-is-an-example-of-such-allocated-memory-What-is-required-to-support-dynamic-memory-allocation-in-the-following-schemes"><a href="#8-12-Most-systems-allow-a-program-to-allocate-more-memory-to-its-address-space-during-execution-Allocation-of-data-in-the-heap-segments-of-programs-is-an-example-of-such-allocated-memory-What-is-required-to-support-dynamic-memory-allocation-in-the-following-schemes" class="headerlink" title="8.12 Most systems allow a program to allocate more memory to its address space during execution. Allocation of data in the heap segments of programs is an example of such allocated memory. What is required to support dynamic memory allocation in the following schemes?"></a>8.12 Most systems allow a program to allocate more memory to its address space during execution. Allocation of data in the heap segments of programs is an example of such allocated memory. What is required to support dynamic memory allocation in the following schemes?</h3><p>大多数系统允许程序在执行过程中为其地址空间分配更多的内存。在程序的堆段中分配数据是这种分配内存的一个例子。在下列方案中，需要什么来支持动态内存分配？</p>
<h4 id="a-Contiguous-memory-allocation"><a href="#a-Contiguous-memory-allocation" class="headerlink" title="a. Contiguous memory allocation"></a>a. Contiguous memory allocation</h4><p>毗连的内存分配 </p>
<p><strong>答：</strong> 程序全部重新分配</p>
<h4 id="b-Pure-segmentation"><a href="#b-Pure-segmentation" class="headerlink" title="b. Pure segmentation"></a>b. Pure segmentation</h4><p>纯segmentation </p>
<p><strong>答：</strong> 分配拓展段</p>
<h4 id="c-Pure-paging"><a href="#c-Pure-paging" class="headerlink" title="c. Pure paging"></a>c. Pure paging</h4><p>纯分页</p>
<p><strong>答：</strong> 分配新分页</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>a.  Contiguous memory allocation: </p>
<p>might require relocation of the entire program since there is not enough space for the program to grow its allocated memory space.</p>
<p>b. Pure segmentation: </p>
<p>might also require relocation of the segment that needs to be extended since there is not enough space for the segment to grow its allocated memory space.</p>
<p>c. Pure paging:</p>
<p>Incremental allocation of new pages is possible in this scheme without requiring relocation of the program’s address space.</p>
<p>a.  毗连的内存分配。</p>
<p>可能需要重新定位整个程序，因为没有足够的空间让程序增长其分配的内存空间。</p>
<p>b. 纯粹的分段。</p>
<p>可能还需要重新定位需要扩展的程序段，因为没有足够的空间让该程序段增加其分配的内存空间。</p>
<p>c. 纯分页。</p>
<p>在这个方案中，新页的增量分配是可能的，不需要重新定位程序的地址空间。</p>
</blockquote>
<h3 id="8-13-Compare-the-memory-organization-schemes-of-contiguous-memory-allocation-pure-segmentation-and-pure-paging-with-respect-to-the-following-issues"><a href="#8-13-Compare-the-memory-organization-schemes-of-contiguous-memory-allocation-pure-segmentation-and-pure-paging-with-respect-to-the-following-issues" class="headerlink" title="8.13 Compare the memory organization schemes of contiguous memory allocation, pure segmentation, and pure paging with respect to the following issues:"></a>8.13 Compare the memory organization schemes of contiguous memory allocation, pure segmentation, and pure paging with respect to the following issues:</h3><p>在以下问题上，比较连续内存分配、纯分段和纯分页的内存组织方案。</p>
<h4 id="a-External-fragmentation"><a href="#a-External-fragmentation" class="headerlink" title="a. External fragmentation"></a>a. External fragmentation</h4><p>外部碎片</p>
<p><strong>答：</strong> 连续内存分配：有；纯分段：有；纯分页：无</p>
<h4 id="b-Internal-fragmentation"><a href="#b-Internal-fragmentation" class="headerlink" title="b. Internal fragmentation"></a>b. Internal fragmentation</h4><p>内部碎片</p>
<p><strong>答：</strong>  连续内存分配：无；纯分段：无；纯分页：有</p>
<h4 id="c-Ability-to-share-code-across-processes"><a href="#c-Ability-to-share-code-across-processes" class="headerlink" title="c. Ability to share code across processes"></a>c. Ability to share code across processes</h4><p>跨进程共享代码的能力</p>
<p><strong>答：</strong> 连续内存分配：不行；纯分段：可；纯分页：可</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>a.  Contiguous memory allocation scheme suffers from external fragmentation as address spaces are allocated contiguously and holes develop as old processes die and new processes are initiated. It also does not allow processes to share code, since a process’s virtual memory segment is not broken into non-contiguous fine-grained segments.</p>
<p>b.  Pure segmentation also suffers from external fragmentation as a segment of a process is laid out contiguously in physical memory and fragmentation would occur as segments of dead processes are replaced by segments of new processes. Segmentation, however, enables processes to share code; for instance, two different processes could share a code segment but have distinct data segments.</p>
<p>c.   Pure paging does not suffer from external fragmentation, but instead suffers from internal fragmentations. Processes are allocated in page granularity and if a page is not completely utilized, it results in internal fragmentation and a corresponding wastage of space. Paging also enables processes to share code at the granularity of pages.</p>
<p>a.  毗连内存分配方案受到外部碎片的影响，因为地址空间是毗连分配的，随着老进程的死亡和新进程的启动，会出现洞。它也不允许进程共享代码，因为一个进程的虚拟内存段没有被分解成非连续的细粒度段。</p>
<p>b.  纯粹的分段也会受到外部碎片的影响，因为一个进程的段在物理内存中是连续布置的，当死亡进程的段被新进程的段所取代时，就会发生碎片化。然而，分段使进程可以共享代码；例如，两个不同的进程可以共享一个代码段，但有不同的数据段。</p>
<p>c.   纯粹的分页不存在外部分片，而是存在内部分片的问题。进程是以页为单位分配的，如果一个页没有被完全利用，就会导致内部碎片化和相应的空间浪费。分页也使进程能够在页的粒度上共享代码。</p>
</blockquote>
<h3 id="8-14-On-a-system-with-paging-a-process-cannot-access-memory-that-it-does-not-own-Why-How-could-the-operating-system-allow-access-to-other-memory-Why-should-it-or-should-it-not"><a href="#8-14-On-a-system-with-paging-a-process-cannot-access-memory-that-it-does-not-own-Why-How-could-the-operating-system-allow-access-to-other-memory-Why-should-it-or-should-it-not" class="headerlink" title="8.14 On a system with paging, a process cannot access memory that it does not own. Why? How could the operating system allow access to other memory? Why should it or should it not?"></a>8.14 On a system with paging, a process cannot access memory that it does not own. Why? How could the operating system allow access to other memory? Why should it or should it not?</h3><p>在一个有分页的系统中，一个进程不能访问它不拥有的内存，为什么？</p>
<p><strong>答：</strong> 保护</p>
<p>操作系统能允许访问其他内存吗？</p>
<p><strong>答：</strong> 能</p>
<p>为什么它应该或不应该？</p>
<p><strong>答：</strong> 因为操作系统得管理内存</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>An address on a paging system is a logical page number and an offset. The physical page is found by searching a table based on the logical page number to produce a physical page number. Because the operating system controls the contents of this table, it can limit a process to accessing only those physical pages allocated to the process. There is no way for a process to refer to a page it does not own because the page will not be in the page table. To allow such access, an operating system simply needs to allow entries for non-process memory to be added to the processs page table. This is useful when two or more processes need to exchange data they just read and write to the same physical addresses (which may be at varying logical addresses). This makes for very efficient interprocess communication.</p>
<p>分页系统上的一个地址是一个逻辑页号和一个偏移量。物理页是通过搜索一个基于逻辑页号的表来产生一个物理页号的。因为操作系统控制着这个表的内容，它可以限制一个进程只访问分配给该进程的物理页。一个进程不可能引用它不拥有的页面，因为该页面不在页表中。为了允许这种访问，操作系统只需要允许非进程内存的条目被添加到进程的页表中。当两个或更多的进程需要交换数据时，这是非常有用的，它们只是对相同的物理地址（可能在不同的逻辑地址）进行读写。这使得进程间的通信非常有效。</p>
</blockquote>
<h3 id="8-15-Explain-why-mobile-operating-systems-such-as-iOS-and-Android-do-not-support-swapping"><a href="#8-15-Explain-why-mobile-operating-systems-such-as-iOS-and-Android-do-not-support-swapping" class="headerlink" title="8.15 Explain why mobile operating systems such as iOS and Android do not support swapping."></a>8.15 Explain why mobile operating systems such as iOS and Android do not support swapping.</h3><p>解释为什么iOS和Android等移动操作系统不支持swap。</p>
<p><strong>答：</strong> 闪存容量小，写入次数有限制，闪存与内存之间的吞吐量差。</p>
<blockquote>
<p>8.2.2 Swapping on Mobile Systems</p>
<p>Although most operating systems for PCs and servers support some modified version of swapping, mobile systems typically do not support swapping in any form. Mobile devices generally use flash memory rather than more spacious hard disks as their persistent storage. The resulting space constraint is one reason why mobile operating-system designers avoid swapping. Other reasons include the limited number of writes that flash memory can tolerate before it becomes unreliable and the poor throughput between main memory and flash memory in these devices. </p>
<p>Instead of using swapping, when free memory falls below a certain threshold, Apple’s iOS asks applications to voluntarily relinquish allocated memory. Read-only data (such as code) are removed from the system and later reloaded from flash memory if necessary. Data that have been modified (such as the stack) are never removed. However, any applications that fail to free up sufficient memory may be terminated by the operating system. </p>
<p>Android does not support swapping and adopts a strategy similar to that used by iOS. It may terminate a process if insufficient free memory is available. However, before terminating a process, Android writes its application state to flash memory so that it can be quickly restarted. </p>
<p>Because of these restrictions, developers for mobile systems must carefully allocate and release memory to ensure that their applications do not use too much memory or suffer from memory leaks. Note that both iOS and Android support paging, so they do have memory-management abilities. We discuss paging later in this chapter.</p>
<p>——教材P360</p>
</blockquote>
<p>然而随着时代的发展，有些移动系统已经开始支持swap</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>Reasons: </p>
<p>First is that these mobile devices typically use flash memory with limited capacity and swapping is avoided because of this space constraint. </p>
<p>Second, flash memory can support a limited number of write operations before it becomes less reliable.</p>
<p>Primarily because Android does not wish for its boot disk to be used as swap space for the reasons outlined in the previous question. However, Android does support swapping, it is just that users must provide their own separate SD card for swap space.</p>
<p>原因是:</p>
<p>首先是这些移动设备通常使用容量有限的闪存，由于这种空间限制，交换被避免了。</p>
<p>第二，闪存在变得不那么可靠之前可以支持有限的写操作。</p>
<p>主要是因为安卓系统不希望其启动盘被用作交换空间，原因见前述问题。然而，安卓系统确实支持交换，只是用户必须提供自己的独立SD卡作为交换空间。</p>
</blockquote>
<h3 id="8-18-Explain-why-address-space-identifiers-ASIDs-are-used"><a href="#8-18-Explain-why-address-space-identifiers-ASIDs-are-used" class="headerlink" title="8.18 Explain why address space identifiers (ASIDs) are used."></a>8.18 Explain why address space identifiers (ASIDs) are used.</h3><p><strong>答：</strong> 确保地址仍有效等作用</p>
<blockquote>
<p>Some TLBs store address-space identifiers (ASIDs) in each TLB entry. An ASID uniquely identifies each process and is used to provide address-space protection for that process. When the TLB attempts to resolve virtual page numbers, it ensures that the ASID for the currently running process matches the ASID associated with the virtual page. If the ASIDs do not match, the attempt is treated as a TLB miss. In addition to providing address-space protection, an ASID allows the TLB to contain entries for several different processes simultaneously. If the TLB does not support separate ASIDs, then every time a new page table is selected (for instance, with each context switch), the TLB must be flushed (or erased) to ensure that the next executing process does not use the wrong translation information. Otherwise, the TLB could include old entries that contain valid virtual addresses but have incorrect or invalid physical addresses left over from the previous process.</p>
<p>——教材P374</p>
</blockquote>
<blockquote>
<p><strong>Answer:</strong></p>
<p>ASIDs provide address space protection in the TLB as well as supporting TLB entries for several different processes at the same time.</p>
<p>If the TLB does not support separate ASIDs, then every time a new page table is selected (context switch), the TLB must be flushed to ensure that the next executing process does not use the wrong translation information.</p>
<p>ASIDs在TLB中提供了地址空间保护，并支持TLB条目同时用于几个不同的进程。</p>
<p>如果TLB不支持独立的ASID，那么每次选择新的页表（上下文切换）时，必须刷新TLB以确保下一个执行进程不会使用错误的翻译信息。</p>
</blockquote>
<h3 id="8-19-Program-binaries-in-many-systems-are-typically-structured-as-follows-Code-is-stored-starting-with-a-small-fixed-virtual-address-such-as-0-The-code-segment-is-followed-by-the-data-segment-that-is-used-for-storing-the-program-variables-When-the-program-starts-executing-the-stack-is-allocated-at-the-other-end-of-the-virtual-address-space-and-is-allowed-to-grow-toward-lower-virtual-addresses-What-is-the-significance-of-this-structure-for-the-following-schemes"><a href="#8-19-Program-binaries-in-many-systems-are-typically-structured-as-follows-Code-is-stored-starting-with-a-small-fixed-virtual-address-such-as-0-The-code-segment-is-followed-by-the-data-segment-that-is-used-for-storing-the-program-variables-When-the-program-starts-executing-the-stack-is-allocated-at-the-other-end-of-the-virtual-address-space-and-is-allowed-to-grow-toward-lower-virtual-addresses-What-is-the-significance-of-this-structure-for-the-following-schemes" class="headerlink" title="8.19 Program binaries in many systems are typically structured as follows. Code is stored starting with a small, fixed virtual address, such as 0. The code segment is followed by the data segment that is used for storing the program variables. When the program starts executing, the stack is allocated at the other end of the virtual address space and is allowed to grow toward lower virtual addresses. What is the significance of this structure for the following schemes?"></a>8.19 Program binaries in many systems are typically structured as follows. Code is stored starting with a small, fixed virtual address, such as 0. The code segment is followed by the data segment that is used for storing the program variables. When the program starts executing, the stack is allocated at the other end of the virtual address space and is allowed to grow toward lower virtual addresses. What is the significance of this structure for the following schemes?</h3><p>许多系统中的程序二进制文件的结构通常如下。代码从一个小的、固定的虚拟地址开始存储，如0。 代码段之后是数据段，用于存储程序变量。当程序开始执行时，堆栈被分配在虚拟地址空间的另一端，并被允许向更低的虚拟地址增长。这种结构对以下方案的意义是什么？</p>
<h4 id="a-Contiguous-memory-allocation-1"><a href="#a-Contiguous-memory-allocation-1" class="headerlink" title="a. Contiguous memory allocation"></a>a. Contiguous memory allocation</h4><p>毗连的内存分配 </p>
<p><strong>答：</strong> 固定大小防止重新分配内存</p>
<h4 id="b-Pure-segmentation-1"><a href="#b-Pure-segmentation-1" class="headerlink" title="b. Pure segmentation"></a>b. Pure segmentation</h4><p>纯分段 </p>
<p><strong>答：</strong> 方便拓展</p>
<h4 id="c-Pure-paging-1"><a href="#c-Pure-paging-1" class="headerlink" title="c. Pure paging"></a>c. Pure paging</h4><p>纯分页 </p>
<p><strong>答：</strong> 方便新分配</p>
<blockquote>
<p><strong>Answer:</strong></p>
<ol>
<li><p>Contiguous-memory allocation requires the operating system to allocate the entire extent of the virtual address space to the program when it starts executing .This could be much higher than the actual memory requirements of the process.</p>
</li>
<li><p>Pure segmentation gives the operating system flexibility to assign a small extent to each segment at program startup time and extend the segment if required.</p>
</li>
<li><p>Pure paging does not require the operating system to allocate the maximum extent of the virtual address space to a process at startup time, but it still requires the operating system to allocate a large page table spanning all of the program’s virtual address space. When a program needs to extend the stack or the heap, it needs to allocate a new page but the corresponding page table entry is preallocated.</p>
</li>
<li><p>毗连内存分配要求操作系统在程序开始执行时分配整个虚拟地址空间的范围，这可能比进程的实际内存需求高得多。</p>
</li>
<li><p>纯粹的分段给了操作系统灵活性，在程序启动时给每个段分配一个小的范围，如果需要的话，可以扩展这个段。</p>
</li>
</ol>
<p>3）纯分页不要求操作系统在启动时给进程分配最大范围的虚拟地址空间，但它仍然要求操作系统分配一个大的分页表，跨越程序的所有虚拟地址空间。当一个程序需要扩展堆栈或堆时，它需要分配一个新的页面，但相应的页表项是预先分配的。</p>
</blockquote>
<h3 id="8-20-Assuming-a-1-KB-page-size-what-are-the-page-numbers-and-offsets-for-the-following-address-references-provided-as-decimal-numbers"><a href="#8-20-Assuming-a-1-KB-page-size-what-are-the-page-numbers-and-offsets-for-the-following-address-references-provided-as-decimal-numbers" class="headerlink" title="8.20 Assuming a 1-KB page size, what are the page numbers and offsets for the following address references (provided as decimal numbers):"></a>8.20 Assuming a 1-KB page size, what are the page numbers and offsets for the following address references (provided as decimal numbers):</h3><p>假设页面大小为1KB，以下地址参考的页码和偏移量是多少（以十进制数字提供）。</p>
<h4 id="a-3085"><a href="#a-3085" class="headerlink" title="a. 3085"></a>a. 3085</h4><p><strong>答：</strong>  3；13</p>
<h4 id="b-42095"><a href="#b-42095" class="headerlink" title="b. 42095"></a>b. 42095</h4><p><strong>答：</strong> 41；111</p>
<h4 id="c-215201"><a href="#c-215201" class="headerlink" title="c. 215201"></a>c. 215201</h4><p><strong>答：</strong> 210；161</p>
<h4 id="d-650000"><a href="#d-650000" class="headerlink" title="d. 650000"></a>d. 650000</h4><p><strong>答：</strong> 634；784</p>
<h4 id="e-2000001"><a href="#e-2000001" class="headerlink" title="e. 2000001"></a>e. 2000001</h4><p><strong>答：</strong> 1953；129</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>Page size =2n=1024 B= 210 B</p>
<table>
<thead>
<tr>
<th>Logical address (decimal)</th>
<th>Page # (decimal)</th>
<th>Offset (decimal)</th>
</tr>
</thead>
<tbody><tr>
<td>3085</td>
<td>3</td>
<td>13</td>
</tr>
<tr>
<td>42095</td>
<td>41</td>
<td>111</td>
</tr>
<tr>
<td>215201</td>
<td>210</td>
<td>161</td>
</tr>
<tr>
<td>650000</td>
<td>634</td>
<td>784</td>
</tr>
<tr>
<td>2000001</td>
<td>1953</td>
<td>129</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="8-21-The-BTV-operating-system-has-a-21-bit-virtual-address-yet-on-certain-embedded-devices-it-has-only-a-16-bit-physical-address-It-also-has-a-2-KB-page-size-How-many-entries-are-there-in-each-of-the-following"><a href="#8-21-The-BTV-operating-system-has-a-21-bit-virtual-address-yet-on-certain-embedded-devices-it-has-only-a-16-bit-physical-address-It-also-has-a-2-KB-page-size-How-many-entries-are-there-in-each-of-the-following" class="headerlink" title="8.21 The BTV operating system has a 21-bit virtual address, yet on certain embedded devices, it has only a 16-bit physical address. It also has a 2-KB page size. How many entries are there in each of the following?"></a>8.21 The BTV operating system has a 21-bit virtual address, yet on certain embedded devices, it has only a 16-bit physical address. It also has a 2-KB page size. How many entries are there in each of the following?</h3><p>BTV操作系统有一个21位的虚拟地址，然而在某些嵌入式设备上，它只有一个16位的物理地址。它也有一个2KB的页面大小。以下每个条目有多少个？</p>
<h4 id="a-A-conventional-single-level-page-table"><a href="#a-A-conventional-single-level-page-table" class="headerlink" title="a. A conventional, single-level page table"></a>a. A conventional, single-level page table</h4><p>一个传统的、单层的页表 </p>
<p><del><strong>答：</strong> $\frac{2^{21}}{2\times 8\times 1024}=128 个$</del></p>
<p> $\frac{2^{21}}{2\times 1024}=1024 个$</p>
<h4 id="b-An-inverted-page-table"><a href="#b-An-inverted-page-table" class="headerlink" title="b. An inverted page table"></a>b. An inverted page table</h4><p>一个倒置的页表</p>
<p><del><strong>答：</strong> $\frac{2^{16}}{2\times 8\times 1024}=4 个$​</del></p>
<p>$\frac{2^{16}}{2\times 1024}=32 个$</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>a. 2^10</p>
<p>b. 2^5</p>
</blockquote>
<h3 id="8-23-Consider-a-logical-address-space-of-256-pages-with-a-4-KB-page-size-mapped-onto-a-physical-memory-of-64-frames"><a href="#8-23-Consider-a-logical-address-space-of-256-pages-with-a-4-KB-page-size-mapped-onto-a-physical-memory-of-64-frames" class="headerlink" title="8.23 Consider a logical address space of 256 pages with a 4-KB page size, mapped onto a physical memory of 64 frames."></a>8.23 Consider a logical address space of 256 pages with a 4-KB page size, mapped onto a physical memory of 64 frames.</h3><p>考虑一个具有4KB页大小的256页的逻辑地址空间，映射到64帧的物理内存上。</p>
<h4 id="a-How-many-bits-are-required-in-the-logical-address"><a href="#a-How-many-bits-are-required-in-the-logical-address" class="headerlink" title="a. How many bits are required in the logical address?"></a>a. How many bits are required in the logical address?</h4><p><strong>答：</strong> $12+8=20 bits$</p>
<h4 id="b-How-many-bits-are-required-in-the-physical-address"><a href="#b-How-many-bits-are-required-in-the-physical-address" class="headerlink" title="b. How many bits are required in the physical address?"></a>b. How many bits are required in the physical address?</h4><p><strong>答：</strong> $12+6=18bits$</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>a.  The logical address requires 8 bits for the page number because there are 256=2^8, of them. Then, the logical address requires 12 bits of the offset because there are 4KB=2^12B of them. So, the logical address requires a total is 20 bits.</p>
<p>b.  The physical address requires 6 bits for the frame number because there are 64=2^6 of them. Then, the physical address also requires 12 bits of the offset because there are 4KB=2^12B them. So, the physical address requires a total is 18 bits.</p>
</blockquote>
<h3 id="8-28-Consider-the-following-segment-table"><a href="#8-28-Consider-the-following-segment-table" class="headerlink" title="8.28 Consider the following segment table:"></a>8.28 Consider the following segment table:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Segment Base Length </span><br><span class="line">------- ---- ------</span><br><span class="line">0       219     600 </span><br><span class="line">1       2300    14 </span><br><span class="line">2       90      100 </span><br><span class="line">3       1327    580 </span><br><span class="line">4       1952    96</span><br></pre></td></tr></table></figure>

<p>What are the physical addresses for the following logical addresses? </p>
<h4 id="a-0-430"><a href="#a-0-430" class="headerlink" title="a. 0,430"></a>a. 0,430</h4><p><strong>答：</strong> 219+430=649</p>
<h4 id="b-1-10"><a href="#b-1-10" class="headerlink" title="b. 1,10"></a>b. 1,10</h4><p><strong>答：</strong> 2300+10=2310</p>
<h4 id="c-2-500"><a href="#c-2-500" class="headerlink" title="c. 2,500"></a>c. 2,500</h4><p><strong>答：</strong> 非法</p>
<h4 id="d-3-400"><a href="#d-3-400" class="headerlink" title="d. 3,400"></a>d. 3,400</h4><p><strong>答：</strong> 1327+400=1727</p>
<h4 id="e-4-112"><a href="#e-4-112" class="headerlink" title="e. 4,112"></a>e. 4,112</h4><p><strong>答：</strong> 非法</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>a.  219 +430 =649. Segment 0 has a length of 600, which is greater than 430.</p>
<p>b.  2300+10=2310. Segment 1 has a length of 14, which is greater than 10.</p>
<p>c.   Illegal reference. </p>
<p>d.  1327+400=1727. Segment 3 has a length of 580, which is greater than 400.</p>
<p>e.  Illegal reference. Segment 4 has a length of 96, which is less than 112.</p>
</blockquote>
<h3 id="8-29-What-is-the-purpose-of-paging-the-page-tables"><a href="#8-29-What-is-the-purpose-of-paging-the-page-tables" class="headerlink" title="8.29 What is the purpose of paging the page tables?"></a>8.29 What is the purpose of paging the page tables?</h3><p>分页页表的目的是什么</p>
<p><strong>答：</strong>  页表本身可能会很大</p>
<blockquote>
<p><strong>Answer:</strong></p>
<p>Since most modern computer systems support a large logical address space (32/64 bits), the page table itself becomes excessively large (space cost). We know <strong>the fact that entire sections of virtual address space are frequently unused</strong>. Paging the page tables have no entries for these spaces, greatly decreasing the amount of memory needed to store virtual memory data structures.</p>
<p>由于大多数现代计算机系统支持大的逻辑地址空间（32/64位），页表本身变得过分庞大（空间成本）。我们知道<strong>的事实是，虚拟地址空间的整个部分经常是未使用的</strong>。分页表没有这些空间的条目，大大减少了存储虚拟内存数据结构所需的内存量。</p>
</blockquote>
<hr>
<p><strong>注：</strong></p>
<p>参考资料：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E9%87%8D%E5%85%A5">可重入 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>[2] Operating System Concepts – 9th Edition 及其答案</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      <div style="display: inline-block;">
        <img src="/images/dogecoin.png" alt="Framist dogecoin">
        <p>dogecoin</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Framist
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://framist.github.io/2021/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E5%85%AB/" title="【操作系统概念-作业8】Main Memory">https://framist.github.io/2021/10/08/操作系统作业八/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"># 学习</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/04/%E3%80%90MiniLCTF2021%E9%A2%98%E8%A7%A3%E3%80%91Web&Crypto&Misc/" rel="prev" title="【MiniLCTF2021题解】Web&Crypto&Misc">
      <i class="fa fa-chevron-left"></i> 【MiniLCTF2021题解】Web&Crypto&Misc
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A%E5%8D%81/" rel="next" title="【操作系统概念-作业10】Mass-Storage Systems">
      【操作系统概念-作业10】Mass-Storage Systems <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-System-Concepts-Exercises-8"><span class="nav-number">1.</span> <span class="nav-text">Operating System Concepts Exercises 8</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E4%B8%8A%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3%E2%80%9C%E4%BB%A3%E7%A0%81%E5%8F%AF%E9%87%8D%E5%85%A5%E2%80%9D"><span class="nav-number">1.1.</span> <span class="nav-text">网上学习理解“代码可重入”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Practice-Exercises"><span class="nav-number">1.2.</span> <span class="nav-text">Practice Exercises</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-Name-two-differences-between-logical-and-physical-addresses"><span class="nav-number">1.2.1.</span> <span class="nav-text">8.1 Name two differences between logical and physical addresses.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-Consider-a-logical-address-space-of-64-pages-of-1-024-words-each-mapped-onto-a-physical-memory-of-32-frames"><span class="nav-number">1.2.2.</span> <span class="nav-text">8.4 Consider a logical address space of 64 pages of 1,024 words each, mapped onto a physical memory of 32 frames.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-How-many-bits-are-there-in-the-logical-address"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">a. How many bits are there in the logical address?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-How-many-bits-are-there-in-the-physical-address"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">b. How many bits are there in the physical address?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-What-is-the-effect-of-allowing-two-entries-in-a-page-table-to-point-to-the-same-page-frame-in-memory-Explain-how-this-effect-could-be-used-to-decrease-the-amount-of-time-needed-to-copy-a-large-amount-of-memory-from-one-place-to-another-What-effect-would-updating-some-byte-on-the-one-page-have-on-the-other-page"><span class="nav-number">1.2.3.</span> <span class="nav-text">8.5 What is the effect of allowing two entries in a page table to point to the same page frame in memory? Explain how this effect could be used to decrease the amount of time needed to copy a large amount of memory from one place to another. What effect would updating some byte on the one page have on the other page?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-Describe-a-mechanism-by-which-one-segment-could-belong-to-the-address-space-of-two-different-processes"><span class="nav-number">1.2.4.</span> <span class="nav-text">8.6  Describe a mechanism by which one segment could belong to the address space of two different processes.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7-Sharing-segments-among-processes-without-requiring-that-they-have-the-same-segment-number-is-possible-in-a-dynamically-linked-segmentation-system"><span class="nav-number">1.2.5.</span> <span class="nav-text">8.7 Sharing segments among processes without requiring that they have the same segment number is possible in a dynamically linked segmentation system.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-Define-a-system-that-allows-static-linking-and-sharing-of-segments-without-requiring-that-the-segment-numbers-be-the-same"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">a. Define a system that allows static linking and sharing of segments without requiring that the segment numbers be the same.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-Describe-a-paging-scheme-that-allows-pages-to-be-shared-without-requiring-that-the-page-numbers-be-the-same"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">b. Describe a paging scheme that allows pages to be shared without requiring that the page numbers be the same.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercises"><span class="nav-number">1.3.</span> <span class="nav-text">Exercises</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-9-Explain-the-difference-between-internal-and-external-fragmentation"><span class="nav-number">1.3.1.</span> <span class="nav-text">8.9 Explain the difference between internal and external fragmentation.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-12-Most-systems-allow-a-program-to-allocate-more-memory-to-its-address-space-during-execution-Allocation-of-data-in-the-heap-segments-of-programs-is-an-example-of-such-allocated-memory-What-is-required-to-support-dynamic-memory-allocation-in-the-following-schemes"><span class="nav-number">1.3.2.</span> <span class="nav-text">8.12 Most systems allow a program to allocate more memory to its address space during execution. Allocation of data in the heap segments of programs is an example of such allocated memory. What is required to support dynamic memory allocation in the following schemes?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-Contiguous-memory-allocation"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">a. Contiguous memory allocation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-Pure-segmentation"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">b. Pure segmentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-Pure-paging"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">c. Pure paging</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-13-Compare-the-memory-organization-schemes-of-contiguous-memory-allocation-pure-segmentation-and-pure-paging-with-respect-to-the-following-issues"><span class="nav-number">1.3.3.</span> <span class="nav-text">8.13 Compare the memory organization schemes of contiguous memory allocation, pure segmentation, and pure paging with respect to the following issues:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-External-fragmentation"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">a. External fragmentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-Internal-fragmentation"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">b. Internal fragmentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-Ability-to-share-code-across-processes"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">c. Ability to share code across processes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-14-On-a-system-with-paging-a-process-cannot-access-memory-that-it-does-not-own-Why-How-could-the-operating-system-allow-access-to-other-memory-Why-should-it-or-should-it-not"><span class="nav-number">1.3.4.</span> <span class="nav-text">8.14 On a system with paging, a process cannot access memory that it does not own. Why? How could the operating system allow access to other memory? Why should it or should it not?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-15-Explain-why-mobile-operating-systems-such-as-iOS-and-Android-do-not-support-swapping"><span class="nav-number">1.3.5.</span> <span class="nav-text">8.15 Explain why mobile operating systems such as iOS and Android do not support swapping.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-18-Explain-why-address-space-identifiers-ASIDs-are-used"><span class="nav-number">1.3.6.</span> <span class="nav-text">8.18 Explain why address space identifiers (ASIDs) are used.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-19-Program-binaries-in-many-systems-are-typically-structured-as-follows-Code-is-stored-starting-with-a-small-fixed-virtual-address-such-as-0-The-code-segment-is-followed-by-the-data-segment-that-is-used-for-storing-the-program-variables-When-the-program-starts-executing-the-stack-is-allocated-at-the-other-end-of-the-virtual-address-space-and-is-allowed-to-grow-toward-lower-virtual-addresses-What-is-the-significance-of-this-structure-for-the-following-schemes"><span class="nav-number">1.3.7.</span> <span class="nav-text">8.19 Program binaries in many systems are typically structured as follows. Code is stored starting with a small, fixed virtual address, such as 0. The code segment is followed by the data segment that is used for storing the program variables. When the program starts executing, the stack is allocated at the other end of the virtual address space and is allowed to grow toward lower virtual addresses. What is the significance of this structure for the following schemes?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-Contiguous-memory-allocation-1"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">a. Contiguous memory allocation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-Pure-segmentation-1"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">b. Pure segmentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-Pure-paging-1"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">c. Pure paging</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-20-Assuming-a-1-KB-page-size-what-are-the-page-numbers-and-offsets-for-the-following-address-references-provided-as-decimal-numbers"><span class="nav-number">1.3.8.</span> <span class="nav-text">8.20 Assuming a 1-KB page size, what are the page numbers and offsets for the following address references (provided as decimal numbers):</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-3085"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">a. 3085</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-42095"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">b. 42095</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-215201"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">c. 215201</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-650000"><span class="nav-number">1.3.8.4.</span> <span class="nav-text">d. 650000</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-2000001"><span class="nav-number">1.3.8.5.</span> <span class="nav-text">e. 2000001</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-21-The-BTV-operating-system-has-a-21-bit-virtual-address-yet-on-certain-embedded-devices-it-has-only-a-16-bit-physical-address-It-also-has-a-2-KB-page-size-How-many-entries-are-there-in-each-of-the-following"><span class="nav-number">1.3.9.</span> <span class="nav-text">8.21 The BTV operating system has a 21-bit virtual address, yet on certain embedded devices, it has only a 16-bit physical address. It also has a 2-KB page size. How many entries are there in each of the following?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-A-conventional-single-level-page-table"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">a. A conventional, single-level page table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-An-inverted-page-table"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">b. An inverted page table</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-23-Consider-a-logical-address-space-of-256-pages-with-a-4-KB-page-size-mapped-onto-a-physical-memory-of-64-frames"><span class="nav-number">1.3.10.</span> <span class="nav-text">8.23 Consider a logical address space of 256 pages with a 4-KB page size, mapped onto a physical memory of 64 frames.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-How-many-bits-are-required-in-the-logical-address"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">a. How many bits are required in the logical address?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-How-many-bits-are-required-in-the-physical-address"><span class="nav-number">1.3.10.2.</span> <span class="nav-text">b. How many bits are required in the physical address?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-28-Consider-the-following-segment-table"><span class="nav-number">1.3.11.</span> <span class="nav-text">8.28 Consider the following segment table:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-0-430"><span class="nav-number">1.3.11.1.</span> <span class="nav-text">a. 0,430</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-1-10"><span class="nav-number">1.3.11.2.</span> <span class="nav-text">b. 1,10</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-2-500"><span class="nav-number">1.3.11.3.</span> <span class="nav-text">c. 2,500</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-3-400"><span class="nav-number">1.3.11.4.</span> <span class="nav-text">d. 3,400</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-4-112"><span class="nav-number">1.3.11.5.</span> <span class="nav-text">e. 4,112</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-29-What-is-the-purpose-of-paging-the-page-tables"><span class="nav-number">1.3.12.</span> <span class="nav-text">8.29 What is the purpose of paging the page tables?</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Framist</p>
  <div class="site-description" itemprop="description">框架主义者的小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/framist" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;framist" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:framist@163.com" title="E-Mail → mailto:framist@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_47102975" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_47102975" rel="noopener" target="_blank"><i class="fas fa-angle-right fa-fw"></i>CSDN</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://framist.github.io/2020/10/11/%E6%88%91%E8%BA%AB%E8%BE%B9%E7%9A%84CS%E5%A4%A7%E4%BD%AC%E4%BB%AC/" title="https:&#x2F;&#x2F;framist.github.io&#x2F;2020&#x2F;10&#x2F;11&#x2F;%E6%88%91%E8%BA%AB%E8%BE%B9%E7%9A%84CS%E5%A4%A7%E4%BD%AC%E4%BB%AC&#x2F;">我身边的大佬们</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yuexiavqiufeng.github.io/" title="https:&#x2F;&#x2F;yuexiavqiufeng.github.io&#x2F;" rel="noopener" target="_blank">yuexiavqiufeng</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://github.com/framist" title="https:&#x2F;&#x2F;github.com&#x2F;framist" rel="noopener" target="_blank">广告位招租</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备2022002862号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-at"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Framist</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script>
    let body = document.getElementsByTagName('body')[0];
    body.addEventListener('click', (e) => {
        let contentArr = ['欧拉~','ˋ( ° ▽、° ) ','RGB!','_(:з」∠)_','哼','?','¿框架?','QAQ',':3','<3','疯掉了',
                            'whoami',
                            '这里没有时间的意义',
                            '嘿嘿嘿，好想被随机异或哦，嘿嘿嘿，嘿嘿嘿，异或我的异或',
                            '记忆赋予时间的意义，而不是时间赋予记忆的意义',
                            '抽象是普适性的代价',
                            '得易见平凡，仿照上例显然',
                            '留作习题答案略，读者自证不难',
                            '反之亦然同理，推论自然成立',
                            '略去过程 Q . E . D ，由上可知证毕'];
        let randomNum = function (n) {
            return Math.floor(Math.random() * n)
        }
        let span = document.createElement('span');
        span.innerHTML = `${contentArr[randomNum(contentArr.length)]}`;
        span.style.color = `rgb(${randomNum(256)},${randomNum(256)},${randomNum(256)})`;
        span.style.position = 'absolute';
        span.style.top = `${e.pageY}px`;
        span.style.left = `${e.pageX}px`;
        span.style.transition = 'all 1s ease';
        span.style.zIndex = 20000;
        body.appendChild(span)
        setTimeout(()=>{
            span.style.top = span.offsetTop - 25 + 'px';
            span.style.opacity = 0;
            setTimeout(()=>{span.remove()},700)
        },700)
    })
</script>




<script type="text/javascript" color="255,255,255" pointColor='255,255,255' opacity='0.5' zIndex="-1" count="233" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '267a9d4a89b9b72b2229',
      clientSecret: '2dba1f14d21da707ed6c4497fecc05d6178b4fa3',
      repo        : 'blog-comment',
      owner       : 'framist',
      admin       : ['framist'],
      id          : 'c853f2a236efd67b059fd6c3e3302604',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
